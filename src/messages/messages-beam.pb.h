// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-hds.proto

#ifndef PROTOBUF_INCLUDED_messages_2dhds_2eproto
#define PROTOBUF_INCLUDED_messages_2dhds_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dhds_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dhds_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dhds_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace hds {
class HdsCoinID;
class HdsCoinIDDefaultTypeInternal;
extern HdsCoinIDDefaultTypeInternal _HdsCoinID_default_instance_;
class HdsECCPoint;
class HdsECCPointDefaultTypeInternal;
extern HdsECCPointDefaultTypeInternal _HdsECCPoint_default_instance_;
class HdsGenerateKey;
class HdsGenerateKeyDefaultTypeInternal;
extern HdsGenerateKeyDefaultTypeInternal _HdsGenerateKey_default_instance_;
class HdsGenerateNonce;
class HdsGenerateNonceDefaultTypeInternal;
extern HdsGenerateNonceDefaultTypeInternal _HdsGenerateNonce_default_instance_;
class HdsGenerateRangeproof;
class HdsGenerateRangeproofDefaultTypeInternal;
extern HdsGenerateRangeproofDefaultTypeInternal _HdsGenerateRangeproof_default_instance_;
class HdsGetNoncePublic;
class HdsGetNoncePublicDefaultTypeInternal;
extern HdsGetNoncePublicDefaultTypeInternal _HdsGetNoncePublic_default_instance_;
class HdsGetNumSlots;
class HdsGetNumSlotsDefaultTypeInternal;
extern HdsGetNumSlotsDefaultTypeInternal _HdsGetNumSlots_default_instance_;
class HdsGetOwnerKey;
class HdsGetOwnerKeyDefaultTypeInternal;
extern HdsGetOwnerKeyDefaultTypeInternal _HdsGetOwnerKey_default_instance_;
class HdsGetPKdf;
class HdsGetPKdfDefaultTypeInternal;
extern HdsGetPKdfDefaultTypeInternal _HdsGetPKdf_default_instance_;
class HdsGetPublicKey;
class HdsGetPublicKeyDefaultTypeInternal;
extern HdsGetPublicKeyDefaultTypeInternal _HdsGetPublicKey_default_instance_;
class HdsKeyIDV;
class HdsKeyIDVDefaultTypeInternal;
extern HdsKeyIDVDefaultTypeInternal _HdsKeyIDV_default_instance_;
class HdsNumSlots;
class HdsNumSlotsDefaultTypeInternal;
extern HdsNumSlotsDefaultTypeInternal _HdsNumSlots_default_instance_;
class HdsOwnerKey;
class HdsOwnerKeyDefaultTypeInternal;
extern HdsOwnerKeyDefaultTypeInternal _HdsOwnerKey_default_instance_;
class HdsPKdf;
class HdsPKdfDefaultTypeInternal;
extern HdsPKdfDefaultTypeInternal _HdsPKdf_default_instance_;
class HdsRangeproofData;
class HdsRangeproofDataDefaultTypeInternal;
extern HdsRangeproofDataDefaultTypeInternal _HdsRangeproofData_default_instance_;
class HdsSignMessage;
class HdsSignMessageDefaultTypeInternal;
extern HdsSignMessageDefaultTypeInternal _HdsSignMessage_default_instance_;
class HdsSignTransaction;
class HdsSignTransactionDefaultTypeInternal;
extern HdsSignTransactionDefaultTypeInternal _HdsSignTransaction_default_instance_;
class HdsSignTransactionReceive;
class HdsSignTransactionReceiveDefaultTypeInternal;
extern HdsSignTransactionReceiveDefaultTypeInternal _HdsSignTransactionReceive_default_instance_;
class HdsSignTransactionReceiveResult;
class HdsSignTransactionReceiveResultDefaultTypeInternal;
extern HdsSignTransactionReceiveResultDefaultTypeInternal _HdsSignTransactionReceiveResult_default_instance_;
class HdsSignTransactionSend;
class HdsSignTransactionSendDefaultTypeInternal;
extern HdsSignTransactionSendDefaultTypeInternal _HdsSignTransactionSend_default_instance_;
class HdsSignTransactionSendResult;
class HdsSignTransactionSendResultDefaultTypeInternal;
extern HdsSignTransactionSendResultDefaultTypeInternal _HdsSignTransactionSendResult_default_instance_;
class HdsSignTransactionSplit;
class HdsSignTransactionSplitDefaultTypeInternal;
extern HdsSignTransactionSplitDefaultTypeInternal _HdsSignTransactionSplit_default_instance_;
class HdsSignTransactionSplitResult;
class HdsSignTransactionSplitResultDefaultTypeInternal;
extern HdsSignTransactionSplitResultDefaultTypeInternal _HdsSignTransactionSplitResult_default_instance_;
class HdsSignTransaction_HdsKernelParametersOld;
class HdsSignTransaction_HdsKernelParametersOldDefaultTypeInternal;
extern HdsSignTransaction_HdsKernelParametersOldDefaultTypeInternal _HdsSignTransaction_HdsKernelParametersOld_default_instance_;
class HdsSignature;
class HdsSignatureDefaultTypeInternal;
extern HdsSignatureDefaultTypeInternal _HdsSignature_default_instance_;
class HdsSignedTransaction;
class HdsSignedTransactionDefaultTypeInternal;
extern HdsSignedTransactionDefaultTypeInternal _HdsSignedTransaction_default_instance_;
class HdsTxCommon;
class HdsTxCommonDefaultTypeInternal;
extern HdsTxCommonDefaultTypeInternal _HdsTxCommon_default_instance_;
class HdsTxCommon_HdsKernelParameters;
class HdsTxCommon_HdsKernelParametersDefaultTypeInternal;
extern HdsTxCommon_HdsKernelParametersDefaultTypeInternal _HdsTxCommon_HdsKernelParameters_default_instance_;
class HdsTxMutualInfo;
class HdsTxMutualInfoDefaultTypeInternal;
extern HdsTxMutualInfoDefaultTypeInternal _HdsTxMutualInfo_default_instance_;
class HdsVerifyMessage;
class HdsVerifyMessageDefaultTypeInternal;
extern HdsVerifyMessageDefaultTypeInternal _HdsVerifyMessage_default_instance_;
}  // namespace hds
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::hds::HdsCoinID* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsCoinID>(Arena*);
template<> ::hw::trezor::messages::hds::HdsECCPoint* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGenerateKey* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGenerateKey>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGenerateNonce* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGenerateNonce>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGenerateRangeproof* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGenerateRangeproof>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGetNoncePublic* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGetNoncePublic>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGetNumSlots* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGetNumSlots>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGetOwnerKey* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGetOwnerKey>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGetPKdf* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGetPKdf>(Arena*);
template<> ::hw::trezor::messages::hds::HdsGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::hds::HdsKeyIDV* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsKeyIDV>(Arena*);
template<> ::hw::trezor::messages::hds::HdsNumSlots* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsNumSlots>(Arena*);
template<> ::hw::trezor::messages::hds::HdsOwnerKey* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsOwnerKey>(Arena*);
template<> ::hw::trezor::messages::hds::HdsPKdf* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsPKdf>(Arena*);
template<> ::hw::trezor::messages::hds::HdsRangeproofData* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsRangeproofData>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignMessage>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransaction* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransaction>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionReceive* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionReceive>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionReceiveResult* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionReceiveResult>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionSend* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSend>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionSendResult* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSendResult>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionSplit* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSplit>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransactionSplitResult* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSplitResult>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignature* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignature>(Arena*);
template<> ::hw::trezor::messages::hds::HdsSignedTransaction* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignedTransaction>(Arena*);
template<> ::hw::trezor::messages::hds::HdsTxCommon* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon>(Arena*);
template<> ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters>(Arena*);
template<> ::hw::trezor::messages::hds::HdsTxMutualInfo* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxMutualInfo>(Arena*);
template<> ::hw::trezor::messages::hds::HdsVerifyMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::hds::HdsVerifyMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace hds {

// ===================================================================

class HdsKeyIDV final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsKeyIDV) */ {
 public:
  HdsKeyIDV();
  virtual ~HdsKeyIDV();

  HdsKeyIDV(const HdsKeyIDV& from);

  inline HdsKeyIDV& operator=(const HdsKeyIDV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsKeyIDV(HdsKeyIDV&& from) noexcept
    : HdsKeyIDV() {
    *this = ::std::move(from);
  }

  inline HdsKeyIDV& operator=(HdsKeyIDV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsKeyIDV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsKeyIDV* internal_default_instance() {
    return reinterpret_cast<const HdsKeyIDV*>(
               &_HdsKeyIDV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HdsKeyIDV* other);
  friend void swap(HdsKeyIDV& a, HdsKeyIDV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsKeyIDV* New() const final {
    return CreateMaybeMessage<HdsKeyIDV>(nullptr);
  }

  HdsKeyIDV* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsKeyIDV>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsKeyIDV& from);
  void MergeFrom(const HdsKeyIDV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsKeyIDV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 idx = 1;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 1;
  ::google::protobuf::uint64 idx() const;
  void set_idx(::google::protobuf::uint64 value);

  // optional uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 sub_idx = 3;
  bool has_sub_idx() const;
  void clear_sub_idx();
  static const int kSubIdxFieldNumber = 3;
  ::google::protobuf::uint32 sub_idx() const;
  void set_sub_idx(::google::protobuf::uint32 value);

  // optional uint64 value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsKeyIDV)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 idx_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 sub_idx_;
  ::google::protobuf::uint64 value_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsCoinID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsCoinID) */ {
 public:
  HdsCoinID();
  virtual ~HdsCoinID();

  HdsCoinID(const HdsCoinID& from);

  inline HdsCoinID& operator=(const HdsCoinID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsCoinID(HdsCoinID&& from) noexcept
    : HdsCoinID() {
    *this = ::std::move(from);
  }

  inline HdsCoinID& operator=(HdsCoinID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsCoinID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsCoinID* internal_default_instance() {
    return reinterpret_cast<const HdsCoinID*>(
               &_HdsCoinID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HdsCoinID* other);
  friend void swap(HdsCoinID& a, HdsCoinID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsCoinID* New() const final {
    return CreateMaybeMessage<HdsCoinID>(nullptr);
  }

  HdsCoinID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsCoinID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsCoinID& from);
  void MergeFrom(const HdsCoinID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsCoinID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 idx = 1;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 1;
  ::google::protobuf::uint64 idx() const;
  void set_idx(::google::protobuf::uint64 value);

  // optional uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 sub_idx = 3;
  bool has_sub_idx() const;
  void clear_sub_idx();
  static const int kSubIdxFieldNumber = 3;
  ::google::protobuf::uint32 sub_idx() const;
  void set_sub_idx(::google::protobuf::uint32 value);

  // optional uint64 amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 asset_id = 5;
  bool has_asset_id() const;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 5;
  ::google::protobuf::uint32 asset_id() const;
  void set_asset_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsCoinID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 idx_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 sub_idx_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 asset_id_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGenerateKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGenerateKey) */ {
 public:
  HdsGenerateKey();
  virtual ~HdsGenerateKey();

  HdsGenerateKey(const HdsGenerateKey& from);

  inline HdsGenerateKey& operator=(const HdsGenerateKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGenerateKey(HdsGenerateKey&& from) noexcept
    : HdsGenerateKey() {
    *this = ::std::move(from);
  }

  inline HdsGenerateKey& operator=(HdsGenerateKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGenerateKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGenerateKey* internal_default_instance() {
    return reinterpret_cast<const HdsGenerateKey*>(
               &_HdsGenerateKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HdsGenerateKey* other);
  friend void swap(HdsGenerateKey& a, HdsGenerateKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGenerateKey* New() const final {
    return CreateMaybeMessage<HdsGenerateKey>(nullptr);
  }

  HdsGenerateKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGenerateKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGenerateKey& from);
  void MergeFrom(const HdsGenerateKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGenerateKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsKeyIDV kidv = 1;
  bool has_kidv() const;
  void clear_kidv();
  static const int kKidvFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsKeyIDV& kidv() const;
  ::hw::trezor::messages::hds::HdsKeyIDV* release_kidv();
  ::hw::trezor::messages::hds::HdsKeyIDV* mutable_kidv();
  void set_allocated_kidv(::hw::trezor::messages::hds::HdsKeyIDV* kidv);

  // optional bool is_coin_key = 2;
  bool has_is_coin_key() const;
  void clear_is_coin_key();
  static const int kIsCoinKeyFieldNumber = 2;
  bool is_coin_key() const;
  void set_is_coin_key(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGenerateKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsKeyIDV* kidv_;
  bool is_coin_key_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGenerateNonce final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGenerateNonce) */ {
 public:
  HdsGenerateNonce();
  virtual ~HdsGenerateNonce();

  HdsGenerateNonce(const HdsGenerateNonce& from);

  inline HdsGenerateNonce& operator=(const HdsGenerateNonce& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGenerateNonce(HdsGenerateNonce&& from) noexcept
    : HdsGenerateNonce() {
    *this = ::std::move(from);
  }

  inline HdsGenerateNonce& operator=(HdsGenerateNonce&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGenerateNonce& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGenerateNonce* internal_default_instance() {
    return reinterpret_cast<const HdsGenerateNonce*>(
               &_HdsGenerateNonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(HdsGenerateNonce* other);
  friend void swap(HdsGenerateNonce& a, HdsGenerateNonce& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGenerateNonce* New() const final {
    return CreateMaybeMessage<HdsGenerateNonce>(nullptr);
  }

  HdsGenerateNonce* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGenerateNonce>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGenerateNonce& from);
  void MergeFrom(const HdsGenerateNonce& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGenerateNonce* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 slot = 1;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 1;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGenerateNonce)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 slot_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGetNoncePublic final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGetNoncePublic) */ {
 public:
  HdsGetNoncePublic();
  virtual ~HdsGetNoncePublic();

  HdsGetNoncePublic(const HdsGetNoncePublic& from);

  inline HdsGetNoncePublic& operator=(const HdsGetNoncePublic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGetNoncePublic(HdsGetNoncePublic&& from) noexcept
    : HdsGetNoncePublic() {
    *this = ::std::move(from);
  }

  inline HdsGetNoncePublic& operator=(HdsGetNoncePublic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGetNoncePublic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGetNoncePublic* internal_default_instance() {
    return reinterpret_cast<const HdsGetNoncePublic*>(
               &_HdsGetNoncePublic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(HdsGetNoncePublic* other);
  friend void swap(HdsGetNoncePublic& a, HdsGetNoncePublic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGetNoncePublic* New() const final {
    return CreateMaybeMessage<HdsGetNoncePublic>(nullptr);
  }

  HdsGetNoncePublic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGetNoncePublic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGetNoncePublic& from);
  void MergeFrom(const HdsGetNoncePublic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGetNoncePublic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 slot = 1;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 1;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGetNoncePublic)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 slot_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsECCPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsECCPoint) */ {
 public:
  HdsECCPoint();
  virtual ~HdsECCPoint();

  HdsECCPoint(const HdsECCPoint& from);

  inline HdsECCPoint& operator=(const HdsECCPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsECCPoint(HdsECCPoint&& from) noexcept
    : HdsECCPoint() {
    *this = ::std::move(from);
  }

  inline HdsECCPoint& operator=(HdsECCPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsECCPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsECCPoint* internal_default_instance() {
    return reinterpret_cast<const HdsECCPoint*>(
               &_HdsECCPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(HdsECCPoint* other);
  friend void swap(HdsECCPoint& a, HdsECCPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsECCPoint* New() const final {
    return CreateMaybeMessage<HdsECCPoint>(nullptr);
  }

  HdsECCPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsECCPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsECCPoint& from);
  void MergeFrom(const HdsECCPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsECCPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // optional bool y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  bool y() const;
  void set_y(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsECCPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  bool y_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignature) */ {
 public:
  HdsSignature();
  virtual ~HdsSignature();

  HdsSignature(const HdsSignature& from);

  inline HdsSignature& operator=(const HdsSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignature(HdsSignature&& from) noexcept
    : HdsSignature() {
    *this = ::std::move(from);
  }

  inline HdsSignature& operator=(HdsSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignature* internal_default_instance() {
    return reinterpret_cast<const HdsSignature*>(
               &_HdsSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(HdsSignature* other);
  friend void swap(HdsSignature& a, HdsSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignature* New() const final {
    return CreateMaybeMessage<HdsSignature>(nullptr);
  }

  HdsSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignature& from);
  void MergeFrom(const HdsSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sign_k = 2;
  bool has_sign_k() const;
  void clear_sign_k();
  static const int kSignKFieldNumber = 2;
  const ::std::string& sign_k() const;
  void set_sign_k(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_k(::std::string&& value);
  #endif
  void set_sign_k(const char* value);
  void set_sign_k(const void* value, size_t size);
  ::std::string* mutable_sign_k();
  ::std::string* release_sign_k();
  void set_allocated_sign_k(::std::string* sign_k);

  // optional .hw.trezor.messages.hds.HdsECCPoint nonce_pub = 1;
  bool has_nonce_pub() const;
  void clear_nonce_pub();
  static const int kNoncePubFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsECCPoint& nonce_pub() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_nonce_pub();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_nonce_pub();
  void set_allocated_nonce_pub(::hw::trezor::messages::hds::HdsECCPoint* nonce_pub);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sign_k_;
  ::hw::trezor::messages::hds::HdsECCPoint* nonce_pub_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignMessage) */ {
 public:
  HdsSignMessage();
  virtual ~HdsSignMessage();

  HdsSignMessage(const HdsSignMessage& from);

  inline HdsSignMessage& operator=(const HdsSignMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignMessage(HdsSignMessage&& from) noexcept
    : HdsSignMessage() {
    *this = ::std::move(from);
  }

  inline HdsSignMessage& operator=(HdsSignMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignMessage* internal_default_instance() {
    return reinterpret_cast<const HdsSignMessage*>(
               &_HdsSignMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HdsSignMessage* other);
  friend void swap(HdsSignMessage& a, HdsSignMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignMessage* New() const final {
    return CreateMaybeMessage<HdsSignMessage>(nullptr);
  }

  HdsSignMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignMessage& from);
  void MergeFrom(const HdsSignMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 1;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional uint64 kid_idx = 2;
  bool has_kid_idx() const;
  void clear_kid_idx();
  static const int kKidIdxFieldNumber = 2;
  ::google::protobuf::uint64 kid_idx() const;
  void set_kid_idx(::google::protobuf::uint64 value);

  // optional uint32 kid_sub_idx = 3;
  bool has_kid_sub_idx() const;
  void clear_kid_sub_idx();
  static const int kKidSubIdxFieldNumber = 3;
  ::google::protobuf::uint32 kid_sub_idx() const;
  void set_kid_sub_idx(::google::protobuf::uint32 value);

  // optional bool show_display = 4;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 4;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::uint64 kid_idx_;
  ::google::protobuf::uint32 kid_sub_idx_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsVerifyMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsVerifyMessage) */ {
 public:
  HdsVerifyMessage();
  virtual ~HdsVerifyMessage();

  HdsVerifyMessage(const HdsVerifyMessage& from);

  inline HdsVerifyMessage& operator=(const HdsVerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsVerifyMessage(HdsVerifyMessage&& from) noexcept
    : HdsVerifyMessage() {
    *this = ::std::move(from);
  }

  inline HdsVerifyMessage& operator=(HdsVerifyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsVerifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsVerifyMessage* internal_default_instance() {
    return reinterpret_cast<const HdsVerifyMessage*>(
               &_HdsVerifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HdsVerifyMessage* other);
  friend void swap(HdsVerifyMessage& a, HdsVerifyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsVerifyMessage* New() const final {
    return CreateMaybeMessage<HdsVerifyMessage>(nullptr);
  }

  HdsVerifyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsVerifyMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsVerifyMessage& from);
  void MergeFrom(const HdsVerifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsVerifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .hw.trezor.messages.hds.HdsSignature signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsSignature& signature() const;
  ::hw::trezor::messages::hds::HdsSignature* release_signature();
  ::hw::trezor::messages::hds::HdsSignature* mutable_signature();
  void set_allocated_signature(::hw::trezor::messages::hds::HdsSignature* signature);

  // optional .hw.trezor.messages.hds.HdsECCPoint public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsECCPoint& public_key() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_public_key();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_public_key();
  void set_allocated_public_key(::hw::trezor::messages::hds::HdsECCPoint* public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsVerifyMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::hw::trezor::messages::hds::HdsSignature* signature_;
  ::hw::trezor::messages::hds::HdsECCPoint* public_key_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGetPublicKey) */ {
 public:
  HdsGetPublicKey();
  virtual ~HdsGetPublicKey();

  HdsGetPublicKey(const HdsGetPublicKey& from);

  inline HdsGetPublicKey& operator=(const HdsGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGetPublicKey(HdsGetPublicKey&& from) noexcept
    : HdsGetPublicKey() {
    *this = ::std::move(from);
  }

  inline HdsGetPublicKey& operator=(HdsGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const HdsGetPublicKey*>(
               &_HdsGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HdsGetPublicKey* other);
  friend void swap(HdsGetPublicKey& a, HdsGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGetPublicKey* New() const final {
    return CreateMaybeMessage<HdsGetPublicKey>(nullptr);
  }

  HdsGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGetPublicKey& from);
  void MergeFrom(const HdsGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 kid_idx = 1;
  bool has_kid_idx() const;
  void clear_kid_idx();
  static const int kKidIdxFieldNumber = 1;
  ::google::protobuf::uint64 kid_idx() const;
  void set_kid_idx(::google::protobuf::uint64 value);

  // optional uint32 kid_sub_idx = 2;
  bool has_kid_sub_idx() const;
  void clear_kid_sub_idx();
  static const int kKidSubIdxFieldNumber = 2;
  ::google::protobuf::uint32 kid_sub_idx() const;
  void set_kid_sub_idx(::google::protobuf::uint32 value);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 kid_idx_;
  ::google::protobuf::uint32 kid_sub_idx_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGetOwnerKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGetOwnerKey) */ {
 public:
  HdsGetOwnerKey();
  virtual ~HdsGetOwnerKey();

  HdsGetOwnerKey(const HdsGetOwnerKey& from);

  inline HdsGetOwnerKey& operator=(const HdsGetOwnerKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGetOwnerKey(HdsGetOwnerKey&& from) noexcept
    : HdsGetOwnerKey() {
    *this = ::std::move(from);
  }

  inline HdsGetOwnerKey& operator=(HdsGetOwnerKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGetOwnerKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGetOwnerKey* internal_default_instance() {
    return reinterpret_cast<const HdsGetOwnerKey*>(
               &_HdsGetOwnerKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(HdsGetOwnerKey* other);
  friend void swap(HdsGetOwnerKey& a, HdsGetOwnerKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGetOwnerKey* New() const final {
    return CreateMaybeMessage<HdsGetOwnerKey>(nullptr);
  }

  HdsGetOwnerKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGetOwnerKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGetOwnerKey& from);
  void MergeFrom(const HdsGetOwnerKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGetOwnerKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool show_display = 1;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 1;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGetOwnerKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsOwnerKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsOwnerKey) */ {
 public:
  HdsOwnerKey();
  virtual ~HdsOwnerKey();

  HdsOwnerKey(const HdsOwnerKey& from);

  inline HdsOwnerKey& operator=(const HdsOwnerKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsOwnerKey(HdsOwnerKey&& from) noexcept
    : HdsOwnerKey() {
    *this = ::std::move(from);
  }

  inline HdsOwnerKey& operator=(HdsOwnerKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsOwnerKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsOwnerKey* internal_default_instance() {
    return reinterpret_cast<const HdsOwnerKey*>(
               &_HdsOwnerKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(HdsOwnerKey* other);
  friend void swap(HdsOwnerKey& a, HdsOwnerKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsOwnerKey* New() const final {
    return CreateMaybeMessage<HdsOwnerKey>(nullptr);
  }

  HdsOwnerKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsOwnerKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsOwnerKey& from);
  void MergeFrom(const HdsOwnerKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsOwnerKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsOwnerKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGenerateRangeproof final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGenerateRangeproof) */ {
 public:
  HdsGenerateRangeproof();
  virtual ~HdsGenerateRangeproof();

  HdsGenerateRangeproof(const HdsGenerateRangeproof& from);

  inline HdsGenerateRangeproof& operator=(const HdsGenerateRangeproof& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGenerateRangeproof(HdsGenerateRangeproof&& from) noexcept
    : HdsGenerateRangeproof() {
    *this = ::std::move(from);
  }

  inline HdsGenerateRangeproof& operator=(HdsGenerateRangeproof&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGenerateRangeproof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGenerateRangeproof* internal_default_instance() {
    return reinterpret_cast<const HdsGenerateRangeproof*>(
               &_HdsGenerateRangeproof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(HdsGenerateRangeproof* other);
  friend void swap(HdsGenerateRangeproof& a, HdsGenerateRangeproof& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGenerateRangeproof* New() const final {
    return CreateMaybeMessage<HdsGenerateRangeproof>(nullptr);
  }

  HdsGenerateRangeproof* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGenerateRangeproof>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGenerateRangeproof& from);
  void MergeFrom(const HdsGenerateRangeproof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGenerateRangeproof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes extra_sk0 = 4;
  bool has_extra_sk0() const;
  void clear_extra_sk0();
  static const int kExtraSk0FieldNumber = 4;
  const ::std::string& extra_sk0() const;
  void set_extra_sk0(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_sk0(::std::string&& value);
  #endif
  void set_extra_sk0(const char* value);
  void set_extra_sk0(const void* value, size_t size);
  ::std::string* mutable_extra_sk0();
  ::std::string* release_extra_sk0();
  void set_allocated_extra_sk0(::std::string* extra_sk0);

  // optional bytes extra_sk1 = 5;
  bool has_extra_sk1() const;
  void clear_extra_sk1();
  static const int kExtraSk1FieldNumber = 5;
  const ::std::string& extra_sk1() const;
  void set_extra_sk1(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_sk1(::std::string&& value);
  #endif
  void set_extra_sk1(const char* value);
  void set_extra_sk1(const void* value, size_t size);
  ::std::string* mutable_extra_sk1();
  ::std::string* release_extra_sk1();
  void set_allocated_extra_sk1(::std::string* extra_sk1);

  // optional .hw.trezor.messages.hds.HdsCoinID cid = 1;
  bool has_cid() const;
  void clear_cid();
  static const int kCidFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsCoinID& cid() const;
  ::hw::trezor::messages::hds::HdsCoinID* release_cid();
  ::hw::trezor::messages::hds::HdsCoinID* mutable_cid();
  void set_allocated_cid(::hw::trezor::messages::hds::HdsCoinID* cid);

  // optional .hw.trezor.messages.hds.HdsECCPoint pt0 = 2;
  bool has_pt0() const;
  void clear_pt0();
  static const int kPt0FieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsECCPoint& pt0() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_pt0();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_pt0();
  void set_allocated_pt0(::hw::trezor::messages::hds::HdsECCPoint* pt0);

  // optional .hw.trezor.messages.hds.HdsECCPoint pt1 = 3;
  bool has_pt1() const;
  void clear_pt1();
  static const int kPt1FieldNumber = 3;
  const ::hw::trezor::messages::hds::HdsECCPoint& pt1() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_pt1();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_pt1();
  void set_allocated_pt1(::hw::trezor::messages::hds::HdsECCPoint* pt1);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGenerateRangeproof)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_sk0_;
  ::google::protobuf::internal::ArenaStringPtr extra_sk1_;
  ::hw::trezor::messages::hds::HdsCoinID* cid_;
  ::hw::trezor::messages::hds::HdsECCPoint* pt0_;
  ::hw::trezor::messages::hds::HdsECCPoint* pt1_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsRangeproofData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsRangeproofData) */ {
 public:
  HdsRangeproofData();
  virtual ~HdsRangeproofData();

  HdsRangeproofData(const HdsRangeproofData& from);

  inline HdsRangeproofData& operator=(const HdsRangeproofData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsRangeproofData(HdsRangeproofData&& from) noexcept
    : HdsRangeproofData() {
    *this = ::std::move(from);
  }

  inline HdsRangeproofData& operator=(HdsRangeproofData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsRangeproofData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsRangeproofData* internal_default_instance() {
    return reinterpret_cast<const HdsRangeproofData*>(
               &_HdsRangeproofData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(HdsRangeproofData* other);
  friend void swap(HdsRangeproofData& a, HdsRangeproofData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsRangeproofData* New() const final {
    return CreateMaybeMessage<HdsRangeproofData>(nullptr);
  }

  HdsRangeproofData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsRangeproofData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsRangeproofData& from);
  void MergeFrom(const HdsRangeproofData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsRangeproofData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_taux = 1;
  bool has_data_taux() const;
  void clear_data_taux();
  static const int kDataTauxFieldNumber = 1;
  const ::std::string& data_taux() const;
  void set_data_taux(const ::std::string& value);
  #if LANG_CXX11
  void set_data_taux(::std::string&& value);
  #endif
  void set_data_taux(const char* value);
  void set_data_taux(const void* value, size_t size);
  ::std::string* mutable_data_taux();
  ::std::string* release_data_taux();
  void set_allocated_data_taux(::std::string* data_taux);

  // optional .hw.trezor.messages.hds.HdsECCPoint pt0 = 3;
  bool has_pt0() const;
  void clear_pt0();
  static const int kPt0FieldNumber = 3;
  const ::hw::trezor::messages::hds::HdsECCPoint& pt0() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_pt0();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_pt0();
  void set_allocated_pt0(::hw::trezor::messages::hds::HdsECCPoint* pt0);

  // optional .hw.trezor.messages.hds.HdsECCPoint pt1 = 4;
  bool has_pt1() const;
  void clear_pt1();
  static const int kPt1FieldNumber = 4;
  const ::hw::trezor::messages::hds::HdsECCPoint& pt1() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_pt1();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_pt1();
  void set_allocated_pt1(::hw::trezor::messages::hds::HdsECCPoint* pt1);

  // optional bool is_successful = 2;
  bool has_is_successful() const;
  void clear_is_successful();
  static const int kIsSuccessfulFieldNumber = 2;
  bool is_successful() const;
  void set_is_successful(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsRangeproofData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_taux_;
  ::hw::trezor::messages::hds::HdsECCPoint* pt0_;
  ::hw::trezor::messages::hds::HdsECCPoint* pt1_;
  bool is_successful_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignedTransaction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignedTransaction) */ {
 public:
  HdsSignedTransaction();
  virtual ~HdsSignedTransaction();

  HdsSignedTransaction(const HdsSignedTransaction& from);

  inline HdsSignedTransaction& operator=(const HdsSignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignedTransaction(HdsSignedTransaction&& from) noexcept
    : HdsSignedTransaction() {
    *this = ::std::move(from);
  }

  inline HdsSignedTransaction& operator=(HdsSignedTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignedTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignedTransaction* internal_default_instance() {
    return reinterpret_cast<const HdsSignedTransaction*>(
               &_HdsSignedTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(HdsSignedTransaction* other);
  friend void swap(HdsSignedTransaction& a, HdsSignedTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignedTransaction* New() const final {
    return CreateMaybeMessage<HdsSignedTransaction>(nullptr);
  }

  HdsSignedTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignedTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignedTransaction& from);
  void MergeFrom(const HdsSignedTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignedTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignedTransaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransaction_HdsKernelParametersOld final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld) */ {
 public:
  HdsSignTransaction_HdsKernelParametersOld();
  virtual ~HdsSignTransaction_HdsKernelParametersOld();

  HdsSignTransaction_HdsKernelParametersOld(const HdsSignTransaction_HdsKernelParametersOld& from);

  inline HdsSignTransaction_HdsKernelParametersOld& operator=(const HdsSignTransaction_HdsKernelParametersOld& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransaction_HdsKernelParametersOld(HdsSignTransaction_HdsKernelParametersOld&& from) noexcept
    : HdsSignTransaction_HdsKernelParametersOld() {
    *this = ::std::move(from);
  }

  inline HdsSignTransaction_HdsKernelParametersOld& operator=(HdsSignTransaction_HdsKernelParametersOld&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransaction_HdsKernelParametersOld& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransaction_HdsKernelParametersOld* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransaction_HdsKernelParametersOld*>(
               &_HdsSignTransaction_HdsKernelParametersOld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(HdsSignTransaction_HdsKernelParametersOld* other);
  friend void swap(HdsSignTransaction_HdsKernelParametersOld& a, HdsSignTransaction_HdsKernelParametersOld& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransaction_HdsKernelParametersOld* New() const final {
    return CreateMaybeMessage<HdsSignTransaction_HdsKernelParametersOld>(nullptr);
  }

  HdsSignTransaction_HdsKernelParametersOld* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransaction_HdsKernelParametersOld>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransaction_HdsKernelParametersOld& from);
  void MergeFrom(const HdsSignTransaction_HdsKernelParametersOld& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransaction_HdsKernelParametersOld* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash_lock = 7;
  bool has_hash_lock() const;
  void clear_hash_lock();
  static const int kHashLockFieldNumber = 7;
  const ::std::string& hash_lock() const;
  void set_hash_lock(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_lock(::std::string&& value);
  #endif
  void set_hash_lock(const char* value);
  void set_hash_lock(const void* value, size_t size);
  ::std::string* mutable_hash_lock();
  ::std::string* release_hash_lock();
  void set_allocated_hash_lock(::std::string* hash_lock);

  // optional .hw.trezor.messages.hds.HdsECCPoint commitment = 2;
  bool has_commitment() const;
  void clear_commitment();
  static const int kCommitmentFieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsECCPoint& commitment() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_commitment();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_commitment();
  void set_allocated_commitment(::hw::trezor::messages::hds::HdsECCPoint* commitment);

  // optional .hw.trezor.messages.hds.HdsECCPoint multisig_nonce = 8;
  bool has_multisig_nonce() const;
  void clear_multisig_nonce();
  static const int kMultisigNonceFieldNumber = 8;
  const ::hw::trezor::messages::hds::HdsECCPoint& multisig_nonce() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_multisig_nonce();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_multisig_nonce();
  void set_allocated_multisig_nonce(::hw::trezor::messages::hds::HdsECCPoint* multisig_nonce);

  // optional .hw.trezor.messages.hds.HdsECCPoint multisig_excess = 9;
  bool has_multisig_excess() const;
  void clear_multisig_excess();
  static const int kMultisigExcessFieldNumber = 9;
  const ::hw::trezor::messages::hds::HdsECCPoint& multisig_excess() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_multisig_excess();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_multisig_excess();
  void set_allocated_multisig_excess(::hw::trezor::messages::hds::HdsECCPoint* multisig_excess);

  // optional uint64 fee = 1;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 1;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 min_height = 4;
  bool has_min_height() const;
  void clear_min_height();
  static const int kMinHeightFieldNumber = 4;
  ::google::protobuf::uint64 min_height() const;
  void set_min_height(::google::protobuf::uint64 value);

  // optional uint64 max_height = 5;
  bool has_max_height() const;
  void clear_max_height();
  static const int kMaxHeightFieldNumber = 5;
  ::google::protobuf::uint64 max_height() const;
  void set_max_height(::google::protobuf::uint64 value);

  // optional sint64 asset_emission = 6;
  bool has_asset_emission() const;
  void clear_asset_emission();
  static const int kAssetEmissionFieldNumber = 6;
  ::google::protobuf::int64 asset_emission() const;
  void set_asset_emission(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_lock_;
  ::hw::trezor::messages::hds::HdsECCPoint* commitment_;
  ::hw::trezor::messages::hds::HdsECCPoint* multisig_nonce_;
  ::hw::trezor::messages::hds::HdsECCPoint* multisig_excess_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 min_height_;
  ::google::protobuf::uint64 max_height_;
  ::google::protobuf::int64 asset_emission_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransaction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransaction) */ {
 public:
  HdsSignTransaction();
  virtual ~HdsSignTransaction();

  HdsSignTransaction(const HdsSignTransaction& from);

  inline HdsSignTransaction& operator=(const HdsSignTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransaction(HdsSignTransaction&& from) noexcept
    : HdsSignTransaction() {
    *this = ::std::move(from);
  }

  inline HdsSignTransaction& operator=(HdsSignTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransaction* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransaction*>(
               &_HdsSignTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(HdsSignTransaction* other);
  friend void swap(HdsSignTransaction& a, HdsSignTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransaction* New() const final {
    return CreateMaybeMessage<HdsSignTransaction>(nullptr);
  }

  HdsSignTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransaction& from);
  void MergeFrom(const HdsSignTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HdsSignTransaction_HdsKernelParametersOld HdsKernelParametersOld;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.hds.HdsKeyIDV inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::hw::trezor::messages::hds::HdsKeyIDV* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >*
      mutable_inputs();
  const ::hw::trezor::messages::hds::HdsKeyIDV& inputs(int index) const;
  ::hw::trezor::messages::hds::HdsKeyIDV* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >&
      inputs() const;

  // repeated .hw.trezor.messages.hds.HdsKeyIDV outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  ::hw::trezor::messages::hds::HdsKeyIDV* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >*
      mutable_outputs();
  const ::hw::trezor::messages::hds::HdsKeyIDV& outputs(int index) const;
  ::hw::trezor::messages::hds::HdsKeyIDV* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >&
      outputs() const;

  // optional bytes offset_sk = 2;
  bool has_offset_sk() const;
  void clear_offset_sk();
  static const int kOffsetSkFieldNumber = 2;
  const ::std::string& offset_sk() const;
  void set_offset_sk(const ::std::string& value);
  #if LANG_CXX11
  void set_offset_sk(::std::string&& value);
  #endif
  void set_offset_sk(const char* value);
  void set_offset_sk(const void* value, size_t size);
  ::std::string* mutable_offset_sk();
  ::std::string* release_offset_sk();
  void set_allocated_offset_sk(::std::string* offset_sk);

  // optional .hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld kernel_params = 5;
  bool has_kernel_params() const;
  void clear_kernel_params();
  static const int kKernelParamsFieldNumber = 5;
  const ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld& kernel_params() const;
  ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* release_kernel_params();
  ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* mutable_kernel_params();
  void set_allocated_kernel_params(::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* kernel_params);

  // optional uint32 nonce_slot = 4;
  bool has_nonce_slot() const;
  void clear_nonce_slot();
  static const int kNonceSlotFieldNumber = 4;
  ::google::protobuf::uint32 nonce_slot() const;
  void set_nonce_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV > outputs_;
  ::google::protobuf::internal::ArenaStringPtr offset_sk_;
  ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* kernel_params_;
  ::google::protobuf::uint32 nonce_slot_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGetPKdf final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGetPKdf) */ {
 public:
  HdsGetPKdf();
  virtual ~HdsGetPKdf();

  HdsGetPKdf(const HdsGetPKdf& from);

  inline HdsGetPKdf& operator=(const HdsGetPKdf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGetPKdf(HdsGetPKdf&& from) noexcept
    : HdsGetPKdf() {
    *this = ::std::move(from);
  }

  inline HdsGetPKdf& operator=(HdsGetPKdf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGetPKdf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGetPKdf* internal_default_instance() {
    return reinterpret_cast<const HdsGetPKdf*>(
               &_HdsGetPKdf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(HdsGetPKdf* other);
  friend void swap(HdsGetPKdf& a, HdsGetPKdf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGetPKdf* New() const final {
    return CreateMaybeMessage<HdsGetPKdf>(nullptr);
  }

  HdsGetPKdf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGetPKdf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGetPKdf& from);
  void MergeFrom(const HdsGetPKdf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGetPKdf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 child_idx = 2;
  bool has_child_idx() const;
  void clear_child_idx();
  static const int kChildIdxFieldNumber = 2;
  ::google::protobuf::uint32 child_idx() const;
  void set_child_idx(::google::protobuf::uint32 value);

  // optional bool is_root_key = 1;
  bool has_is_root_key() const;
  void clear_is_root_key();
  static const int kIsRootKeyFieldNumber = 1;
  bool is_root_key() const;
  void set_is_root_key(bool value);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGetPKdf)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 child_idx_;
  bool is_root_key_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsPKdf final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsPKdf) */ {
 public:
  HdsPKdf();
  virtual ~HdsPKdf();

  HdsPKdf(const HdsPKdf& from);

  inline HdsPKdf& operator=(const HdsPKdf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsPKdf(HdsPKdf&& from) noexcept
    : HdsPKdf() {
    *this = ::std::move(from);
  }

  inline HdsPKdf& operator=(HdsPKdf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsPKdf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsPKdf* internal_default_instance() {
    return reinterpret_cast<const HdsPKdf*>(
               &_HdsPKdf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(HdsPKdf* other);
  friend void swap(HdsPKdf& a, HdsPKdf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsPKdf* New() const final {
    return CreateMaybeMessage<HdsPKdf>(nullptr);
  }

  HdsPKdf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsPKdf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsPKdf& from);
  void MergeFrom(const HdsPKdf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsPKdf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .hw.trezor.messages.hds.HdsECCPoint cofactor_G = 2;
  bool has_cofactor_g() const;
  void clear_cofactor_g();
  static const int kCofactorGFieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsECCPoint& cofactor_g() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_cofactor_g();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_cofactor_g();
  void set_allocated_cofactor_g(::hw::trezor::messages::hds::HdsECCPoint* cofactor_g);

  // optional .hw.trezor.messages.hds.HdsECCPoint cofactor_J = 3;
  bool has_cofactor_j() const;
  void clear_cofactor_j();
  static const int kCofactorJFieldNumber = 3;
  const ::hw::trezor::messages::hds::HdsECCPoint& cofactor_j() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_cofactor_j();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_cofactor_j();
  void set_allocated_cofactor_j(::hw::trezor::messages::hds::HdsECCPoint* cofactor_j);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsPKdf)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::hw::trezor::messages::hds::HdsECCPoint* cofactor_g_;
  ::hw::trezor::messages::hds::HdsECCPoint* cofactor_j_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsGetNumSlots final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsGetNumSlots) */ {
 public:
  HdsGetNumSlots();
  virtual ~HdsGetNumSlots();

  HdsGetNumSlots(const HdsGetNumSlots& from);

  inline HdsGetNumSlots& operator=(const HdsGetNumSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsGetNumSlots(HdsGetNumSlots&& from) noexcept
    : HdsGetNumSlots() {
    *this = ::std::move(from);
  }

  inline HdsGetNumSlots& operator=(HdsGetNumSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsGetNumSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsGetNumSlots* internal_default_instance() {
    return reinterpret_cast<const HdsGetNumSlots*>(
               &_HdsGetNumSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(HdsGetNumSlots* other);
  friend void swap(HdsGetNumSlots& a, HdsGetNumSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsGetNumSlots* New() const final {
    return CreateMaybeMessage<HdsGetNumSlots>(nullptr);
  }

  HdsGetNumSlots* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsGetNumSlots>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsGetNumSlots& from);
  void MergeFrom(const HdsGetNumSlots& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsGetNumSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool show_display = 1;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 1;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsGetNumSlots)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsNumSlots final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsNumSlots) */ {
 public:
  HdsNumSlots();
  virtual ~HdsNumSlots();

  HdsNumSlots(const HdsNumSlots& from);

  inline HdsNumSlots& operator=(const HdsNumSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsNumSlots(HdsNumSlots&& from) noexcept
    : HdsNumSlots() {
    *this = ::std::move(from);
  }

  inline HdsNumSlots& operator=(HdsNumSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsNumSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsNumSlots* internal_default_instance() {
    return reinterpret_cast<const HdsNumSlots*>(
               &_HdsNumSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(HdsNumSlots* other);
  friend void swap(HdsNumSlots& a, HdsNumSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsNumSlots* New() const final {
    return CreateMaybeMessage<HdsNumSlots>(nullptr);
  }

  HdsNumSlots* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsNumSlots>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsNumSlots& from);
  void MergeFrom(const HdsNumSlots& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsNumSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_slots = 1;
  bool has_num_slots() const;
  void clear_num_slots();
  static const int kNumSlotsFieldNumber = 1;
  ::google::protobuf::uint32 num_slots() const;
  void set_num_slots(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsNumSlots)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 num_slots_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsTxCommon_HdsKernelParameters final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters) */ {
 public:
  HdsTxCommon_HdsKernelParameters();
  virtual ~HdsTxCommon_HdsKernelParameters();

  HdsTxCommon_HdsKernelParameters(const HdsTxCommon_HdsKernelParameters& from);

  inline HdsTxCommon_HdsKernelParameters& operator=(const HdsTxCommon_HdsKernelParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsTxCommon_HdsKernelParameters(HdsTxCommon_HdsKernelParameters&& from) noexcept
    : HdsTxCommon_HdsKernelParameters() {
    *this = ::std::move(from);
  }

  inline HdsTxCommon_HdsKernelParameters& operator=(HdsTxCommon_HdsKernelParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsTxCommon_HdsKernelParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsTxCommon_HdsKernelParameters* internal_default_instance() {
    return reinterpret_cast<const HdsTxCommon_HdsKernelParameters*>(
               &_HdsTxCommon_HdsKernelParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(HdsTxCommon_HdsKernelParameters* other);
  friend void swap(HdsTxCommon_HdsKernelParameters& a, HdsTxCommon_HdsKernelParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsTxCommon_HdsKernelParameters* New() const final {
    return CreateMaybeMessage<HdsTxCommon_HdsKernelParameters>(nullptr);
  }

  HdsTxCommon_HdsKernelParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsTxCommon_HdsKernelParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsTxCommon_HdsKernelParameters& from);
  void MergeFrom(const HdsTxCommon_HdsKernelParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsTxCommon_HdsKernelParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsECCPoint commitment = 4;
  bool has_commitment() const;
  void clear_commitment();
  static const int kCommitmentFieldNumber = 4;
  const ::hw::trezor::messages::hds::HdsECCPoint& commitment() const;
  ::hw::trezor::messages::hds::HdsECCPoint* release_commitment();
  ::hw::trezor::messages::hds::HdsECCPoint* mutable_commitment();
  void set_allocated_commitment(::hw::trezor::messages::hds::HdsECCPoint* commitment);

  // optional .hw.trezor.messages.hds.HdsSignature signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::hw::trezor::messages::hds::HdsSignature& signature() const;
  ::hw::trezor::messages::hds::HdsSignature* release_signature();
  ::hw::trezor::messages::hds::HdsSignature* mutable_signature();
  void set_allocated_signature(::hw::trezor::messages::hds::HdsSignature* signature);

  // optional uint64 fee = 1;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 1;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint64 min_height = 2;
  bool has_min_height() const;
  void clear_min_height();
  static const int kMinHeightFieldNumber = 2;
  ::google::protobuf::uint64 min_height() const;
  void set_min_height(::google::protobuf::uint64 value);

  // optional uint64 max_height = 3;
  bool has_max_height() const;
  void clear_max_height();
  static const int kMaxHeightFieldNumber = 3;
  ::google::protobuf::uint64 max_height() const;
  void set_max_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsECCPoint* commitment_;
  ::hw::trezor::messages::hds::HdsSignature* signature_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint64 min_height_;
  ::google::protobuf::uint64 max_height_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsTxCommon final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsTxCommon) */ {
 public:
  HdsTxCommon();
  virtual ~HdsTxCommon();

  HdsTxCommon(const HdsTxCommon& from);

  inline HdsTxCommon& operator=(const HdsTxCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsTxCommon(HdsTxCommon&& from) noexcept
    : HdsTxCommon() {
    *this = ::std::move(from);
  }

  inline HdsTxCommon& operator=(HdsTxCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsTxCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsTxCommon* internal_default_instance() {
    return reinterpret_cast<const HdsTxCommon*>(
               &_HdsTxCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(HdsTxCommon* other);
  friend void swap(HdsTxCommon& a, HdsTxCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsTxCommon* New() const final {
    return CreateMaybeMessage<HdsTxCommon>(nullptr);
  }

  HdsTxCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsTxCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsTxCommon& from);
  void MergeFrom(const HdsTxCommon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsTxCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HdsTxCommon_HdsKernelParameters HdsKernelParameters;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.hds.HdsCoinID inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::hw::trezor::messages::hds::HdsCoinID* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >*
      mutable_inputs();
  const ::hw::trezor::messages::hds::HdsCoinID& inputs(int index) const;
  ::hw::trezor::messages::hds::HdsCoinID* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >&
      inputs() const;

  // repeated .hw.trezor.messages.hds.HdsCoinID outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  ::hw::trezor::messages::hds::HdsCoinID* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >*
      mutable_outputs();
  const ::hw::trezor::messages::hds::HdsCoinID& outputs(int index) const;
  ::hw::trezor::messages::hds::HdsCoinID* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >&
      outputs() const;

  // optional bytes offset_sk = 2;
  bool has_offset_sk() const;
  void clear_offset_sk();
  static const int kOffsetSkFieldNumber = 2;
  const ::std::string& offset_sk() const;
  void set_offset_sk(const ::std::string& value);
  #if LANG_CXX11
  void set_offset_sk(::std::string&& value);
  #endif
  void set_offset_sk(const char* value);
  void set_offset_sk(const void* value, size_t size);
  ::std::string* mutable_offset_sk();
  ::std::string* release_offset_sk();
  void set_allocated_offset_sk(::std::string* offset_sk);

  // optional .hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters kernel_params = 4;
  bool has_kernel_params() const;
  void clear_kernel_params();
  static const int kKernelParamsFieldNumber = 4;
  const ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters& kernel_params() const;
  ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* release_kernel_params();
  ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* mutable_kernel_params();
  void set_allocated_kernel_params(::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* kernel_params);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsTxCommon)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID > outputs_;
  ::google::protobuf::internal::ArenaStringPtr offset_sk_;
  ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* kernel_params_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsTxMutualInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsTxMutualInfo) */ {
 public:
  HdsTxMutualInfo();
  virtual ~HdsTxMutualInfo();

  HdsTxMutualInfo(const HdsTxMutualInfo& from);

  inline HdsTxMutualInfo& operator=(const HdsTxMutualInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsTxMutualInfo(HdsTxMutualInfo&& from) noexcept
    : HdsTxMutualInfo() {
    *this = ::std::move(from);
  }

  inline HdsTxMutualInfo& operator=(HdsTxMutualInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsTxMutualInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsTxMutualInfo* internal_default_instance() {
    return reinterpret_cast<const HdsTxMutualInfo*>(
               &_HdsTxMutualInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(HdsTxMutualInfo* other);
  friend void swap(HdsTxMutualInfo& a, HdsTxMutualInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsTxMutualInfo* New() const final {
    return CreateMaybeMessage<HdsTxMutualInfo>(nullptr);
  }

  HdsTxMutualInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsTxMutualInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsTxMutualInfo& from);
  void MergeFrom(const HdsTxMutualInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsTxMutualInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::std::string& peer() const;
  void set_peer(const ::std::string& value);
  #if LANG_CXX11
  void set_peer(::std::string&& value);
  #endif
  void set_peer(const char* value);
  void set_peer(const void* value, size_t size);
  ::std::string* mutable_peer();
  ::std::string* release_peer();
  void set_allocated_peer(::std::string* peer);

  // optional .hw.trezor.messages.hds.HdsSignature payment_proof_signature = 3;
  bool has_payment_proof_signature() const;
  void clear_payment_proof_signature();
  static const int kPaymentProofSignatureFieldNumber = 3;
  const ::hw::trezor::messages::hds::HdsSignature& payment_proof_signature() const;
  ::hw::trezor::messages::hds::HdsSignature* release_payment_proof_signature();
  ::hw::trezor::messages::hds::HdsSignature* mutable_payment_proof_signature();
  void set_allocated_payment_proof_signature(::hw::trezor::messages::hds::HdsSignature* payment_proof_signature);

  // optional uint64 wallet_identity_key = 2;
  bool has_wallet_identity_key() const;
  void clear_wallet_identity_key();
  static const int kWalletIdentityKeyFieldNumber = 2;
  ::google::protobuf::uint64 wallet_identity_key() const;
  void set_wallet_identity_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsTxMutualInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_;
  ::hw::trezor::messages::hds::HdsSignature* payment_proof_signature_;
  ::google::protobuf::uint64 wallet_identity_key_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionSend final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionSend) */ {
 public:
  HdsSignTransactionSend();
  virtual ~HdsSignTransactionSend();

  HdsSignTransactionSend(const HdsSignTransactionSend& from);

  inline HdsSignTransactionSend& operator=(const HdsSignTransactionSend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionSend(HdsSignTransactionSend&& from) noexcept
    : HdsSignTransactionSend() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionSend& operator=(HdsSignTransactionSend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionSend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionSend* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionSend*>(
               &_HdsSignTransactionSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(HdsSignTransactionSend* other);
  friend void swap(HdsSignTransactionSend& a, HdsSignTransactionSend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionSend* New() const final {
    return CreateMaybeMessage<HdsSignTransactionSend>(nullptr);
  }

  HdsSignTransactionSend* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionSend>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionSend& from);
  void MergeFrom(const HdsSignTransactionSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionSend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_agreement = 4;
  bool has_user_agreement() const;
  void clear_user_agreement();
  static const int kUserAgreementFieldNumber = 4;
  const ::std::string& user_agreement() const;
  void set_user_agreement(const ::std::string& value);
  #if LANG_CXX11
  void set_user_agreement(::std::string&& value);
  #endif
  void set_user_agreement(const char* value);
  void set_user_agreement(const void* value, size_t size);
  ::std::string* mutable_user_agreement();
  ::std::string* release_user_agreement();
  void set_allocated_user_agreement(::std::string* user_agreement);

  // optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
  bool has_tx_common() const;
  void clear_tx_common();
  static const int kTxCommonFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsTxCommon& tx_common() const;
  ::hw::trezor::messages::hds::HdsTxCommon* release_tx_common();
  ::hw::trezor::messages::hds::HdsTxCommon* mutable_tx_common();
  void set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common);

  // optional .hw.trezor.messages.hds.HdsTxMutualInfo tx_mutual_info = 2;
  bool has_tx_mutual_info() const;
  void clear_tx_mutual_info();
  static const int kTxMutualInfoFieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsTxMutualInfo& tx_mutual_info() const;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* release_tx_mutual_info();
  ::hw::trezor::messages::hds::HdsTxMutualInfo* mutable_tx_mutual_info();
  void set_allocated_tx_mutual_info(::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info);

  // optional uint32 nonce_slot = 3;
  bool has_nonce_slot() const;
  void clear_nonce_slot();
  static const int kNonceSlotFieldNumber = 3;
  ::google::protobuf::uint32 nonce_slot() const;
  void set_nonce_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionSend)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_agreement_;
  ::hw::trezor::messages::hds::HdsTxCommon* tx_common_;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info_;
  ::google::protobuf::uint32 nonce_slot_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionSendResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionSendResult) */ {
 public:
  HdsSignTransactionSendResult();
  virtual ~HdsSignTransactionSendResult();

  HdsSignTransactionSendResult(const HdsSignTransactionSendResult& from);

  inline HdsSignTransactionSendResult& operator=(const HdsSignTransactionSendResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionSendResult(HdsSignTransactionSendResult&& from) noexcept
    : HdsSignTransactionSendResult() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionSendResult& operator=(HdsSignTransactionSendResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionSendResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionSendResult* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionSendResult*>(
               &_HdsSignTransactionSendResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(HdsSignTransactionSendResult* other);
  friend void swap(HdsSignTransactionSendResult& a, HdsSignTransactionSendResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionSendResult* New() const final {
    return CreateMaybeMessage<HdsSignTransactionSendResult>(nullptr);
  }

  HdsSignTransactionSendResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionSendResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionSendResult& from);
  void MergeFrom(const HdsSignTransactionSendResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionSendResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsSignTransactionSend tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsSignTransactionSend& tx() const;
  ::hw::trezor::messages::hds::HdsSignTransactionSend* release_tx();
  ::hw::trezor::messages::hds::HdsSignTransactionSend* mutable_tx();
  void set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionSend* tx);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionSendResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsSignTransactionSend* tx_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionReceive final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionReceive) */ {
 public:
  HdsSignTransactionReceive();
  virtual ~HdsSignTransactionReceive();

  HdsSignTransactionReceive(const HdsSignTransactionReceive& from);

  inline HdsSignTransactionReceive& operator=(const HdsSignTransactionReceive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionReceive(HdsSignTransactionReceive&& from) noexcept
    : HdsSignTransactionReceive() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionReceive& operator=(HdsSignTransactionReceive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionReceive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionReceive* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionReceive*>(
               &_HdsSignTransactionReceive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(HdsSignTransactionReceive* other);
  friend void swap(HdsSignTransactionReceive& a, HdsSignTransactionReceive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionReceive* New() const final {
    return CreateMaybeMessage<HdsSignTransactionReceive>(nullptr);
  }

  HdsSignTransactionReceive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionReceive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionReceive& from);
  void MergeFrom(const HdsSignTransactionReceive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionReceive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
  bool has_tx_common() const;
  void clear_tx_common();
  static const int kTxCommonFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsTxCommon& tx_common() const;
  ::hw::trezor::messages::hds::HdsTxCommon* release_tx_common();
  ::hw::trezor::messages::hds::HdsTxCommon* mutable_tx_common();
  void set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common);

  // optional .hw.trezor.messages.hds.HdsTxMutualInfo tx_mutual_info = 2;
  bool has_tx_mutual_info() const;
  void clear_tx_mutual_info();
  static const int kTxMutualInfoFieldNumber = 2;
  const ::hw::trezor::messages::hds::HdsTxMutualInfo& tx_mutual_info() const;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* release_tx_mutual_info();
  ::hw::trezor::messages::hds::HdsTxMutualInfo* mutable_tx_mutual_info();
  void set_allocated_tx_mutual_info(::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionReceive)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsTxCommon* tx_common_;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionReceiveResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionReceiveResult) */ {
 public:
  HdsSignTransactionReceiveResult();
  virtual ~HdsSignTransactionReceiveResult();

  HdsSignTransactionReceiveResult(const HdsSignTransactionReceiveResult& from);

  inline HdsSignTransactionReceiveResult& operator=(const HdsSignTransactionReceiveResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionReceiveResult(HdsSignTransactionReceiveResult&& from) noexcept
    : HdsSignTransactionReceiveResult() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionReceiveResult& operator=(HdsSignTransactionReceiveResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionReceiveResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionReceiveResult* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionReceiveResult*>(
               &_HdsSignTransactionReceiveResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(HdsSignTransactionReceiveResult* other);
  friend void swap(HdsSignTransactionReceiveResult& a, HdsSignTransactionReceiveResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionReceiveResult* New() const final {
    return CreateMaybeMessage<HdsSignTransactionReceiveResult>(nullptr);
  }

  HdsSignTransactionReceiveResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionReceiveResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionReceiveResult& from);
  void MergeFrom(const HdsSignTransactionReceiveResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionReceiveResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsSignTransactionReceive tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsSignTransactionReceive& tx() const;
  ::hw::trezor::messages::hds::HdsSignTransactionReceive* release_tx();
  ::hw::trezor::messages::hds::HdsSignTransactionReceive* mutable_tx();
  void set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionReceive* tx);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionReceiveResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsSignTransactionReceive* tx_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionSplit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionSplit) */ {
 public:
  HdsSignTransactionSplit();
  virtual ~HdsSignTransactionSplit();

  HdsSignTransactionSplit(const HdsSignTransactionSplit& from);

  inline HdsSignTransactionSplit& operator=(const HdsSignTransactionSplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionSplit(HdsSignTransactionSplit&& from) noexcept
    : HdsSignTransactionSplit() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionSplit& operator=(HdsSignTransactionSplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionSplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionSplit* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionSplit*>(
               &_HdsSignTransactionSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(HdsSignTransactionSplit* other);
  friend void swap(HdsSignTransactionSplit& a, HdsSignTransactionSplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionSplit* New() const final {
    return CreateMaybeMessage<HdsSignTransactionSplit>(nullptr);
  }

  HdsSignTransactionSplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionSplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionSplit& from);
  void MergeFrom(const HdsSignTransactionSplit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionSplit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
  bool has_tx_common() const;
  void clear_tx_common();
  static const int kTxCommonFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsTxCommon& tx_common() const;
  ::hw::trezor::messages::hds::HdsTxCommon* release_tx_common();
  ::hw::trezor::messages::hds::HdsTxCommon* mutable_tx_common();
  void set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionSplit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsTxCommon* tx_common_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// -------------------------------------------------------------------

class HdsSignTransactionSplitResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.hds.HdsSignTransactionSplitResult) */ {
 public:
  HdsSignTransactionSplitResult();
  virtual ~HdsSignTransactionSplitResult();

  HdsSignTransactionSplitResult(const HdsSignTransactionSplitResult& from);

  inline HdsSignTransactionSplitResult& operator=(const HdsSignTransactionSplitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HdsSignTransactionSplitResult(HdsSignTransactionSplitResult&& from) noexcept
    : HdsSignTransactionSplitResult() {
    *this = ::std::move(from);
  }

  inline HdsSignTransactionSplitResult& operator=(HdsSignTransactionSplitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HdsSignTransactionSplitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdsSignTransactionSplitResult* internal_default_instance() {
    return reinterpret_cast<const HdsSignTransactionSplitResult*>(
               &_HdsSignTransactionSplitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(HdsSignTransactionSplitResult* other);
  friend void swap(HdsSignTransactionSplitResult& a, HdsSignTransactionSplitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HdsSignTransactionSplitResult* New() const final {
    return CreateMaybeMessage<HdsSignTransactionSplitResult>(nullptr);
  }

  HdsSignTransactionSplitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HdsSignTransactionSplitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HdsSignTransactionSplitResult& from);
  void MergeFrom(const HdsSignTransactionSplitResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdsSignTransactionSplitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.hds.HdsSignTransactionSplit tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::hw::trezor::messages::hds::HdsSignTransactionSplit& tx() const;
  ::hw::trezor::messages::hds::HdsSignTransactionSplit* release_tx();
  ::hw::trezor::messages::hds::HdsSignTransactionSplit* mutable_tx();
  void set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionSplit* tx);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.hds.HdsSignTransactionSplitResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::hds::HdsSignTransactionSplit* tx_;
  friend struct ::TableStruct_messages_2dhds_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HdsKeyIDV

// optional uint64 idx = 1;
inline bool HdsKeyIDV::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsKeyIDV::clear_idx() {
  idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 HdsKeyIDV::idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsKeyIDV.idx)
  return idx_;
}
inline void HdsKeyIDV::set_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsKeyIDV.idx)
}

// optional uint32 type = 2;
inline bool HdsKeyIDV::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsKeyIDV::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 HdsKeyIDV::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsKeyIDV.type)
  return type_;
}
inline void HdsKeyIDV::set_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsKeyIDV.type)
}

// optional uint32 sub_idx = 3;
inline bool HdsKeyIDV::has_sub_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsKeyIDV::clear_sub_idx() {
  sub_idx_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 HdsKeyIDV::sub_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsKeyIDV.sub_idx)
  return sub_idx_;
}
inline void HdsKeyIDV::set_sub_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  sub_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsKeyIDV.sub_idx)
}

// optional uint64 value = 4;
inline bool HdsKeyIDV::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsKeyIDV::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 HdsKeyIDV::value() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsKeyIDV.value)
  return value_;
}
inline void HdsKeyIDV::set_value(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  value_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsKeyIDV.value)
}

// -------------------------------------------------------------------

// HdsCoinID

// optional uint64 idx = 1;
inline bool HdsCoinID::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsCoinID::clear_idx() {
  idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 HdsCoinID::idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsCoinID.idx)
  return idx_;
}
inline void HdsCoinID::set_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsCoinID.idx)
}

// optional uint32 type = 2;
inline bool HdsCoinID::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsCoinID::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 HdsCoinID::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsCoinID.type)
  return type_;
}
inline void HdsCoinID::set_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsCoinID.type)
}

// optional uint32 sub_idx = 3;
inline bool HdsCoinID::has_sub_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsCoinID::clear_sub_idx() {
  sub_idx_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 HdsCoinID::sub_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsCoinID.sub_idx)
  return sub_idx_;
}
inline void HdsCoinID::set_sub_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  sub_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsCoinID.sub_idx)
}

// optional uint64 amount = 4;
inline bool HdsCoinID::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsCoinID::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 HdsCoinID::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsCoinID.amount)
  return amount_;
}
inline void HdsCoinID::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsCoinID.amount)
}

// optional uint32 asset_id = 5;
inline bool HdsCoinID::has_asset_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HdsCoinID::clear_asset_id() {
  asset_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 HdsCoinID::asset_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsCoinID.asset_id)
  return asset_id_;
}
inline void HdsCoinID::set_asset_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  asset_id_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsCoinID.asset_id)
}

// -------------------------------------------------------------------

// HdsGenerateKey

// optional .hw.trezor.messages.hds.HdsKeyIDV kidv = 1;
inline bool HdsGenerateKey::has_kidv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGenerateKey::clear_kidv() {
  if (kidv_ != nullptr) kidv_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsKeyIDV& HdsGenerateKey::kidv() const {
  const ::hw::trezor::messages::hds::HdsKeyIDV* p = kidv_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateKey.kidv)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsKeyIDV*>(
      &::hw::trezor::messages::hds::_HdsKeyIDV_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsGenerateKey::release_kidv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateKey.kidv)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsKeyIDV* temp = kidv_;
  kidv_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsGenerateKey::mutable_kidv() {
  _has_bits_[0] |= 0x00000001u;
  if (kidv_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsKeyIDV>(GetArenaNoVirtual());
    kidv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateKey.kidv)
  return kidv_;
}
inline void HdsGenerateKey::set_allocated_kidv(::hw::trezor::messages::hds::HdsKeyIDV* kidv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kidv_;
  }
  if (kidv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kidv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kidv, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  kidv_ = kidv;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateKey.kidv)
}

// optional bool is_coin_key = 2;
inline bool HdsGenerateKey::has_is_coin_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsGenerateKey::clear_is_coin_key() {
  is_coin_key_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool HdsGenerateKey::is_coin_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateKey.is_coin_key)
  return is_coin_key_;
}
inline void HdsGenerateKey::set_is_coin_key(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_coin_key_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGenerateKey.is_coin_key)
}

// -------------------------------------------------------------------

// HdsGenerateNonce

// optional uint32 slot = 1;
inline bool HdsGenerateNonce::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGenerateNonce::clear_slot() {
  slot_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 HdsGenerateNonce::slot() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateNonce.slot)
  return slot_;
}
inline void HdsGenerateNonce::set_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  slot_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGenerateNonce.slot)
}

// -------------------------------------------------------------------

// HdsGetNoncePublic

// optional uint32 slot = 1;
inline bool HdsGetNoncePublic::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGetNoncePublic::clear_slot() {
  slot_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 HdsGetNoncePublic::slot() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetNoncePublic.slot)
  return slot_;
}
inline void HdsGetNoncePublic::set_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  slot_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetNoncePublic.slot)
}

// -------------------------------------------------------------------

// HdsECCPoint

// optional bytes x = 1;
inline bool HdsECCPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsECCPoint::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsECCPoint::x() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsECCPoint.x)
  return x_.GetNoArena();
}
inline void HdsECCPoint::set_x(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsECCPoint.x)
}
#if LANG_CXX11
inline void HdsECCPoint::set_x(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsECCPoint.x)
}
#endif
inline void HdsECCPoint::set_x(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsECCPoint.x)
}
inline void HdsECCPoint::set_x(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsECCPoint.x)
}
inline ::std::string* HdsECCPoint::mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsECCPoint.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsECCPoint::release_x() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsECCPoint.x)
  if (!has_x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return x_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsECCPoint::set_allocated_x(::std::string* x) {
  if (x != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsECCPoint.x)
}

// optional bool y = 2;
inline bool HdsECCPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsECCPoint::clear_y() {
  y_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool HdsECCPoint::y() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsECCPoint.y)
  return y_;
}
inline void HdsECCPoint::set_y(bool value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsECCPoint.y)
}

// -------------------------------------------------------------------

// HdsSignature

// optional .hw.trezor.messages.hds.HdsECCPoint nonce_pub = 1;
inline bool HdsSignature::has_nonce_pub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignature::clear_nonce_pub() {
  if (nonce_pub_ != nullptr) nonce_pub_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsSignature::nonce_pub() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = nonce_pub_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignature.nonce_pub)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignature::release_nonce_pub() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignature.nonce_pub)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = nonce_pub_;
  nonce_pub_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignature::mutable_nonce_pub() {
  _has_bits_[0] |= 0x00000002u;
  if (nonce_pub_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    nonce_pub_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignature.nonce_pub)
  return nonce_pub_;
}
inline void HdsSignature::set_allocated_nonce_pub(::hw::trezor::messages::hds::HdsECCPoint* nonce_pub) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nonce_pub_;
  }
  if (nonce_pub) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nonce_pub = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nonce_pub, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nonce_pub_ = nonce_pub;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignature.nonce_pub)
}

// optional bytes sign_k = 2;
inline bool HdsSignature::has_sign_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignature::clear_sign_k() {
  sign_k_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignature::sign_k() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignature.sign_k)
  return sign_k_.GetNoArena();
}
inline void HdsSignature::set_sign_k(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sign_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignature.sign_k)
}
#if LANG_CXX11
inline void HdsSignature::set_sign_k(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sign_k_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignature.sign_k)
}
#endif
inline void HdsSignature::set_sign_k(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sign_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignature.sign_k)
}
inline void HdsSignature::set_sign_k(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sign_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignature.sign_k)
}
inline ::std::string* HdsSignature::mutable_sign_k() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignature.sign_k)
  return sign_k_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignature::release_sign_k() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignature.sign_k)
  if (!has_sign_k()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sign_k_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignature::set_allocated_sign_k(::std::string* sign_k) {
  if (sign_k != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sign_k_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_k);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignature.sign_k)
}

// -------------------------------------------------------------------

// HdsSignMessage

// optional string msg = 1;
inline bool HdsSignMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignMessage::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignMessage::msg() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignMessage.msg)
  return msg_.GetNoArena();
}
inline void HdsSignMessage::set_msg(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignMessage.msg)
}
#if LANG_CXX11
inline void HdsSignMessage::set_msg(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignMessage.msg)
}
#endif
inline void HdsSignMessage::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignMessage.msg)
}
inline void HdsSignMessage::set_msg(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignMessage.msg)
}
inline ::std::string* HdsSignMessage::mutable_msg() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignMessage.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignMessage::release_msg() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignMessage.msg)
  if (!has_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignMessage::set_allocated_msg(::std::string* msg) {
  if (msg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignMessage.msg)
}

// optional uint64 kid_idx = 2;
inline bool HdsSignMessage::has_kid_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignMessage::clear_kid_idx() {
  kid_idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 HdsSignMessage::kid_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignMessage.kid_idx)
  return kid_idx_;
}
inline void HdsSignMessage::set_kid_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  kid_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignMessage.kid_idx)
}

// optional uint32 kid_sub_idx = 3;
inline bool HdsSignMessage::has_kid_sub_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsSignMessage::clear_kid_sub_idx() {
  kid_sub_idx_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 HdsSignMessage::kid_sub_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignMessage.kid_sub_idx)
  return kid_sub_idx_;
}
inline void HdsSignMessage::set_kid_sub_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  kid_sub_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignMessage.kid_sub_idx)
}

// optional bool show_display = 4;
inline bool HdsSignMessage::has_show_display() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsSignMessage::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool HdsSignMessage::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignMessage.show_display)
  return show_display_;
}
inline void HdsSignMessage::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000008u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignMessage.show_display)
}

// -------------------------------------------------------------------

// HdsVerifyMessage

// optional .hw.trezor.messages.hds.HdsSignature signature = 1;
inline bool HdsVerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsVerifyMessage::clear_signature() {
  if (signature_ != nullptr) signature_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsSignature& HdsVerifyMessage::signature() const {
  const ::hw::trezor::messages::hds::HdsSignature* p = signature_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsVerifyMessage.signature)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignature*>(
      &::hw::trezor::messages::hds::_HdsSignature_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsVerifyMessage::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsVerifyMessage.signature)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsSignature* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsVerifyMessage::mutable_signature() {
  _has_bits_[0] |= 0x00000002u;
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignature>(GetArenaNoVirtual());
    signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsVerifyMessage.signature)
  return signature_;
}
inline void HdsVerifyMessage::set_allocated_signature(::hw::trezor::messages::hds::HdsSignature* signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsVerifyMessage.signature)
}

// optional .hw.trezor.messages.hds.HdsECCPoint public_key = 2;
inline bool HdsVerifyMessage::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsVerifyMessage::clear_public_key() {
  if (public_key_ != nullptr) public_key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsVerifyMessage::public_key() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = public_key_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsVerifyMessage.public_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsVerifyMessage::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsVerifyMessage.public_key)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsVerifyMessage::mutable_public_key() {
  _has_bits_[0] |= 0x00000004u;
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    public_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsVerifyMessage.public_key)
  return public_key_;
}
inline void HdsVerifyMessage::set_allocated_public_key(::hw::trezor::messages::hds::HdsECCPoint* public_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete public_key_;
  }
  if (public_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      public_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsVerifyMessage.public_key)
}

// optional bytes message = 3;
inline bool HdsVerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsVerifyMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsVerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsVerifyMessage.message)
  return message_.GetNoArena();
}
inline void HdsVerifyMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsVerifyMessage.message)
}
#if LANG_CXX11
inline void HdsVerifyMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsVerifyMessage.message)
}
#endif
inline void HdsVerifyMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsVerifyMessage.message)
}
inline void HdsVerifyMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsVerifyMessage.message)
}
inline ::std::string* HdsVerifyMessage::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsVerifyMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsVerifyMessage::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsVerifyMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsVerifyMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsVerifyMessage.message)
}

// -------------------------------------------------------------------

// HdsGetPublicKey

// optional uint64 kid_idx = 1;
inline bool HdsGetPublicKey::has_kid_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGetPublicKey::clear_kid_idx() {
  kid_idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 HdsGetPublicKey::kid_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPublicKey.kid_idx)
  return kid_idx_;
}
inline void HdsGetPublicKey::set_kid_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  kid_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPublicKey.kid_idx)
}

// optional uint32 kid_sub_idx = 2;
inline bool HdsGetPublicKey::has_kid_sub_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsGetPublicKey::clear_kid_sub_idx() {
  kid_sub_idx_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 HdsGetPublicKey::kid_sub_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPublicKey.kid_sub_idx)
  return kid_sub_idx_;
}
inline void HdsGetPublicKey::set_kid_sub_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  kid_sub_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPublicKey.kid_sub_idx)
}

// optional bool show_display = 3;
inline bool HdsGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool HdsGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPublicKey.show_display)
  return show_display_;
}
inline void HdsGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000004u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// HdsGetOwnerKey

// optional bool show_display = 1;
inline bool HdsGetOwnerKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGetOwnerKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool HdsGetOwnerKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetOwnerKey.show_display)
  return show_display_;
}
inline void HdsGetOwnerKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetOwnerKey.show_display)
}

// -------------------------------------------------------------------

// HdsOwnerKey

// optional bytes key = 1;
inline bool HdsOwnerKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsOwnerKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsOwnerKey::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsOwnerKey.key)
  return key_.GetNoArena();
}
inline void HdsOwnerKey::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsOwnerKey.key)
}
#if LANG_CXX11
inline void HdsOwnerKey::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsOwnerKey.key)
}
#endif
inline void HdsOwnerKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsOwnerKey.key)
}
inline void HdsOwnerKey::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsOwnerKey.key)
}
inline ::std::string* HdsOwnerKey::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsOwnerKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsOwnerKey::release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsOwnerKey.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsOwnerKey::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsOwnerKey.key)
}

// -------------------------------------------------------------------

// HdsGenerateRangeproof

// optional .hw.trezor.messages.hds.HdsCoinID cid = 1;
inline bool HdsGenerateRangeproof::has_cid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsGenerateRangeproof::clear_cid() {
  if (cid_ != nullptr) cid_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsCoinID& HdsGenerateRangeproof::cid() const {
  const ::hw::trezor::messages::hds::HdsCoinID* p = cid_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateRangeproof.cid)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsCoinID*>(
      &::hw::trezor::messages::hds::_HdsCoinID_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsGenerateRangeproof::release_cid() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateRangeproof.cid)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsCoinID* temp = cid_;
  cid_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsGenerateRangeproof::mutable_cid() {
  _has_bits_[0] |= 0x00000004u;
  if (cid_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsCoinID>(GetArenaNoVirtual());
    cid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateRangeproof.cid)
  return cid_;
}
inline void HdsGenerateRangeproof::set_allocated_cid(::hw::trezor::messages::hds::HdsCoinID* cid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cid_;
  }
  if (cid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cid_ = cid;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateRangeproof.cid)
}

// optional .hw.trezor.messages.hds.HdsECCPoint pt0 = 2;
inline bool HdsGenerateRangeproof::has_pt0() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsGenerateRangeproof::clear_pt0() {
  if (pt0_ != nullptr) pt0_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsGenerateRangeproof::pt0() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = pt0_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateRangeproof.pt0)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsGenerateRangeproof::release_pt0() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateRangeproof.pt0)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = pt0_;
  pt0_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsGenerateRangeproof::mutable_pt0() {
  _has_bits_[0] |= 0x00000008u;
  if (pt0_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    pt0_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateRangeproof.pt0)
  return pt0_;
}
inline void HdsGenerateRangeproof::set_allocated_pt0(::hw::trezor::messages::hds::HdsECCPoint* pt0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pt0_;
  }
  if (pt0) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pt0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pt0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pt0_ = pt0;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateRangeproof.pt0)
}

// optional .hw.trezor.messages.hds.HdsECCPoint pt1 = 3;
inline bool HdsGenerateRangeproof::has_pt1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HdsGenerateRangeproof::clear_pt1() {
  if (pt1_ != nullptr) pt1_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsGenerateRangeproof::pt1() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = pt1_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateRangeproof.pt1)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsGenerateRangeproof::release_pt1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateRangeproof.pt1)
  _has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = pt1_;
  pt1_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsGenerateRangeproof::mutable_pt1() {
  _has_bits_[0] |= 0x00000010u;
  if (pt1_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    pt1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateRangeproof.pt1)
  return pt1_;
}
inline void HdsGenerateRangeproof::set_allocated_pt1(::hw::trezor::messages::hds::HdsECCPoint* pt1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pt1_;
  }
  if (pt1) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pt1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pt1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  pt1_ = pt1;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateRangeproof.pt1)
}

// optional bytes extra_sk0 = 4;
inline bool HdsGenerateRangeproof::has_extra_sk0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGenerateRangeproof::clear_extra_sk0() {
  extra_sk0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsGenerateRangeproof::extra_sk0() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
  return extra_sk0_.GetNoArena();
}
inline void HdsGenerateRangeproof::set_extra_sk0(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_sk0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
}
#if LANG_CXX11
inline void HdsGenerateRangeproof::set_extra_sk0(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_sk0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
}
#endif
inline void HdsGenerateRangeproof::set_extra_sk0(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  extra_sk0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
}
inline void HdsGenerateRangeproof::set_extra_sk0(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  extra_sk0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
}
inline ::std::string* HdsGenerateRangeproof::mutable_extra_sk0() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
  return extra_sk0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsGenerateRangeproof::release_extra_sk0() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
  if (!has_extra_sk0()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_sk0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsGenerateRangeproof::set_allocated_extra_sk0(::std::string* extra_sk0) {
  if (extra_sk0 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_sk0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_sk0);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk0)
}

// optional bytes extra_sk1 = 5;
inline bool HdsGenerateRangeproof::has_extra_sk1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsGenerateRangeproof::clear_extra_sk1() {
  extra_sk1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& HdsGenerateRangeproof::extra_sk1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
  return extra_sk1_.GetNoArena();
}
inline void HdsGenerateRangeproof::set_extra_sk1(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  extra_sk1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
}
#if LANG_CXX11
inline void HdsGenerateRangeproof::set_extra_sk1(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  extra_sk1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
}
#endif
inline void HdsGenerateRangeproof::set_extra_sk1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  extra_sk1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
}
inline void HdsGenerateRangeproof::set_extra_sk1(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  extra_sk1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
}
inline ::std::string* HdsGenerateRangeproof::mutable_extra_sk1() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
  return extra_sk1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsGenerateRangeproof::release_extra_sk1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
  if (!has_extra_sk1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return extra_sk1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsGenerateRangeproof::set_allocated_extra_sk1(::std::string* extra_sk1) {
  if (extra_sk1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extra_sk1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_sk1);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsGenerateRangeproof.extra_sk1)
}

// -------------------------------------------------------------------

// HdsRangeproofData

// optional bytes data_taux = 1;
inline bool HdsRangeproofData::has_data_taux() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsRangeproofData::clear_data_taux() {
  data_taux_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsRangeproofData::data_taux() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
  return data_taux_.GetNoArena();
}
inline void HdsRangeproofData::set_data_taux(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_taux_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
}
#if LANG_CXX11
inline void HdsRangeproofData::set_data_taux(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_taux_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
}
#endif
inline void HdsRangeproofData::set_data_taux(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_taux_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
}
inline void HdsRangeproofData::set_data_taux(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_taux_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
}
inline ::std::string* HdsRangeproofData::mutable_data_taux() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
  return data_taux_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsRangeproofData::release_data_taux() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
  if (!has_data_taux()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_taux_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsRangeproofData::set_allocated_data_taux(::std::string* data_taux) {
  if (data_taux != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_taux_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_taux);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsRangeproofData.data_taux)
}

// optional bool is_successful = 2;
inline bool HdsRangeproofData::has_is_successful() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsRangeproofData::clear_is_successful() {
  is_successful_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool HdsRangeproofData::is_successful() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsRangeproofData.is_successful)
  return is_successful_;
}
inline void HdsRangeproofData::set_is_successful(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_successful_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsRangeproofData.is_successful)
}

// optional .hw.trezor.messages.hds.HdsECCPoint pt0 = 3;
inline bool HdsRangeproofData::has_pt0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsRangeproofData::clear_pt0() {
  if (pt0_ != nullptr) pt0_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsRangeproofData::pt0() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = pt0_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsRangeproofData.pt0)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsRangeproofData::release_pt0() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsRangeproofData.pt0)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = pt0_;
  pt0_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsRangeproofData::mutable_pt0() {
  _has_bits_[0] |= 0x00000002u;
  if (pt0_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    pt0_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsRangeproofData.pt0)
  return pt0_;
}
inline void HdsRangeproofData::set_allocated_pt0(::hw::trezor::messages::hds::HdsECCPoint* pt0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pt0_;
  }
  if (pt0) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pt0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pt0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pt0_ = pt0;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsRangeproofData.pt0)
}

// optional .hw.trezor.messages.hds.HdsECCPoint pt1 = 4;
inline bool HdsRangeproofData::has_pt1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsRangeproofData::clear_pt1() {
  if (pt1_ != nullptr) pt1_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsRangeproofData::pt1() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = pt1_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsRangeproofData.pt1)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsRangeproofData::release_pt1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsRangeproofData.pt1)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = pt1_;
  pt1_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsRangeproofData::mutable_pt1() {
  _has_bits_[0] |= 0x00000004u;
  if (pt1_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    pt1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsRangeproofData.pt1)
  return pt1_;
}
inline void HdsRangeproofData::set_allocated_pt1(::hw::trezor::messages::hds::HdsECCPoint* pt1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pt1_;
  }
  if (pt1) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pt1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pt1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pt1_ = pt1;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsRangeproofData.pt1)
}

// -------------------------------------------------------------------

// HdsSignedTransaction

// optional bytes signature = 1;
inline bool HdsSignedTransaction::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignedTransaction::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignedTransaction::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignedTransaction.signature)
  return signature_.GetNoArena();
}
inline void HdsSignedTransaction::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignedTransaction.signature)
}
#if LANG_CXX11
inline void HdsSignedTransaction::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignedTransaction.signature)
}
#endif
inline void HdsSignedTransaction::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignedTransaction.signature)
}
inline void HdsSignedTransaction::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignedTransaction.signature)
}
inline ::std::string* HdsSignedTransaction::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignedTransaction.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignedTransaction::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignedTransaction.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignedTransaction::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignedTransaction.signature)
}

// -------------------------------------------------------------------

// HdsSignTransaction_HdsKernelParametersOld

// optional uint64 fee = 1;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_fee() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 HdsSignTransaction_HdsKernelParametersOld::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.fee)
  return fee_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.fee)
}

// optional .hw.trezor.messages.hds.HdsECCPoint commitment = 2;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_commitment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_commitment() {
  if (commitment_ != nullptr) commitment_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsSignTransaction_HdsKernelParametersOld::commitment() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = commitment_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.commitment)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::release_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.commitment)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = commitment_;
  commitment_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::mutable_commitment() {
  _has_bits_[0] |= 0x00000002u;
  if (commitment_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    commitment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.commitment)
  return commitment_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_allocated_commitment(::hw::trezor::messages::hds::HdsECCPoint* commitment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commitment_;
  }
  if (commitment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commitment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commitment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commitment_ = commitment;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.commitment)
}

// optional uint64 min_height = 4;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_min_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_min_height() {
  min_height_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 HdsSignTransaction_HdsKernelParametersOld::min_height() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.min_height)
  return min_height_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_min_height(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  min_height_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.min_height)
}

// optional uint64 max_height = 5;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_max_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_max_height() {
  max_height_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 HdsSignTransaction_HdsKernelParametersOld::max_height() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.max_height)
  return max_height_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_max_height(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  max_height_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.max_height)
}

// optional sint64 asset_emission = 6;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_asset_emission() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_asset_emission() {
  asset_emission_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::int64 HdsSignTransaction_HdsKernelParametersOld::asset_emission() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.asset_emission)
  return asset_emission_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_asset_emission(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  asset_emission_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.asset_emission)
}

// optional bytes hash_lock = 7;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_hash_lock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_hash_lock() {
  hash_lock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignTransaction_HdsKernelParametersOld::hash_lock() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
  return hash_lock_.GetNoArena();
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_hash_lock(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
}
#if LANG_CXX11
inline void HdsSignTransaction_HdsKernelParametersOld::set_hash_lock(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_lock_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
}
#endif
inline void HdsSignTransaction_HdsKernelParametersOld::set_hash_lock(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_hash_lock(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
}
inline ::std::string* HdsSignTransaction_HdsKernelParametersOld::mutable_hash_lock() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
  return hash_lock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignTransaction_HdsKernelParametersOld::release_hash_lock() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
  if (!has_hash_lock()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_lock_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_allocated_hash_lock(::std::string* hash_lock) {
  if (hash_lock != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_lock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_lock);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.hash_lock)
}

// optional .hw.trezor.messages.hds.HdsECCPoint multisig_nonce = 8;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_multisig_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_multisig_nonce() {
  if (multisig_nonce_ != nullptr) multisig_nonce_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsSignTransaction_HdsKernelParametersOld::multisig_nonce() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = multisig_nonce_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_nonce)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::release_multisig_nonce() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_nonce)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = multisig_nonce_;
  multisig_nonce_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::mutable_multisig_nonce() {
  _has_bits_[0] |= 0x00000004u;
  if (multisig_nonce_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    multisig_nonce_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_nonce)
  return multisig_nonce_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_allocated_multisig_nonce(::hw::trezor::messages::hds::HdsECCPoint* multisig_nonce) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_nonce_;
  }
  if (multisig_nonce) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig_nonce = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig_nonce, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  multisig_nonce_ = multisig_nonce;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_nonce)
}

// optional .hw.trezor.messages.hds.HdsECCPoint multisig_excess = 9;
inline bool HdsSignTransaction_HdsKernelParametersOld::has_multisig_excess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsSignTransaction_HdsKernelParametersOld::clear_multisig_excess() {
  if (multisig_excess_ != nullptr) multisig_excess_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsSignTransaction_HdsKernelParametersOld::multisig_excess() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = multisig_excess_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_excess)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::release_multisig_excess() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_excess)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = multisig_excess_;
  multisig_excess_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsSignTransaction_HdsKernelParametersOld::mutable_multisig_excess() {
  _has_bits_[0] |= 0x00000008u;
  if (multisig_excess_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    multisig_excess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_excess)
  return multisig_excess_;
}
inline void HdsSignTransaction_HdsKernelParametersOld::set_allocated_multisig_excess(::hw::trezor::messages::hds::HdsECCPoint* multisig_excess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_excess_;
  }
  if (multisig_excess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig_excess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig_excess, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  multisig_excess_ = multisig_excess;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld.multisig_excess)
}

// -------------------------------------------------------------------

// HdsSignTransaction

// repeated .hw.trezor.messages.hds.HdsKeyIDV inputs = 1;
inline int HdsSignTransaction::inputs_size() const {
  return inputs_.size();
}
inline void HdsSignTransaction::clear_inputs() {
  inputs_.Clear();
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsSignTransaction::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >*
HdsSignTransaction::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.hds.HdsSignTransaction.inputs)
  return &inputs_;
}
inline const ::hw::trezor::messages::hds::HdsKeyIDV& HdsSignTransaction::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.inputs)
  return inputs_.Get(index);
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsSignTransaction::add_inputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.hds.HdsSignTransaction.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >&
HdsSignTransaction::inputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.hds.HdsSignTransaction.inputs)
  return inputs_;
}

// optional bytes offset_sk = 2;
inline bool HdsSignTransaction::has_offset_sk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransaction::clear_offset_sk() {
  offset_sk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignTransaction::offset_sk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
  return offset_sk_.GetNoArena();
}
inline void HdsSignTransaction::set_offset_sk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
}
#if LANG_CXX11
inline void HdsSignTransaction::set_offset_sk(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
}
#endif
inline void HdsSignTransaction::set_offset_sk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
}
inline void HdsSignTransaction::set_offset_sk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
}
inline ::std::string* HdsSignTransaction::mutable_offset_sk() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
  return offset_sk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignTransaction::release_offset_sk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
  if (!has_offset_sk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return offset_sk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignTransaction::set_allocated_offset_sk(::std::string* offset_sk) {
  if (offset_sk != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  offset_sk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), offset_sk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.offset_sk)
}

// repeated .hw.trezor.messages.hds.HdsKeyIDV outputs = 3;
inline int HdsSignTransaction::outputs_size() const {
  return outputs_.size();
}
inline void HdsSignTransaction::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsSignTransaction::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >*
HdsSignTransaction::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.hds.HdsSignTransaction.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::hds::HdsKeyIDV& HdsSignTransaction::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::hds::HdsKeyIDV* HdsSignTransaction::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.hds.HdsSignTransaction.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsKeyIDV >&
HdsSignTransaction::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.hds.HdsSignTransaction.outputs)
  return outputs_;
}

// optional uint32 nonce_slot = 4;
inline bool HdsSignTransaction::has_nonce_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsSignTransaction::clear_nonce_slot() {
  nonce_slot_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 HdsSignTransaction::nonce_slot() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.nonce_slot)
  return nonce_slot_;
}
inline void HdsSignTransaction::set_nonce_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  nonce_slot_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransaction.nonce_slot)
}

// optional .hw.trezor.messages.hds.HdsSignTransaction.HdsKernelParametersOld kernel_params = 5;
inline bool HdsSignTransaction::has_kernel_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignTransaction::clear_kernel_params() {
  if (kernel_params_ != nullptr) kernel_params_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld& HdsSignTransaction::kernel_params() const {
  const ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* p = kernel_params_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransaction.kernel_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld*>(
      &::hw::trezor::messages::hds::_HdsSignTransaction_HdsKernelParametersOld_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* HdsSignTransaction::release_kernel_params() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransaction.kernel_params)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* temp = kernel_params_;
  kernel_params_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* HdsSignTransaction::mutable_kernel_params() {
  _has_bits_[0] |= 0x00000002u;
  if (kernel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld>(GetArenaNoVirtual());
    kernel_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransaction.kernel_params)
  return kernel_params_;
}
inline void HdsSignTransaction::set_allocated_kernel_params(::hw::trezor::messages::hds::HdsSignTransaction_HdsKernelParametersOld* kernel_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kernel_params_;
  }
  if (kernel_params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kernel_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kernel_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  kernel_params_ = kernel_params;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransaction.kernel_params)
}

// -------------------------------------------------------------------

// HdsGetPKdf

// optional bool is_root_key = 1;
inline bool HdsGetPKdf::has_is_root_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsGetPKdf::clear_is_root_key() {
  is_root_key_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool HdsGetPKdf::is_root_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPKdf.is_root_key)
  return is_root_key_;
}
inline void HdsGetPKdf::set_is_root_key(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_root_key_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPKdf.is_root_key)
}

// optional uint32 child_idx = 2;
inline bool HdsGetPKdf::has_child_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGetPKdf::clear_child_idx() {
  child_idx_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 HdsGetPKdf::child_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPKdf.child_idx)
  return child_idx_;
}
inline void HdsGetPKdf::set_child_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  child_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPKdf.child_idx)
}

// optional bool show_display = 3;
inline bool HdsGetPKdf::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsGetPKdf::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool HdsGetPKdf::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetPKdf.show_display)
  return show_display_;
}
inline void HdsGetPKdf::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000004u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetPKdf.show_display)
}

// -------------------------------------------------------------------

// HdsPKdf

// optional bytes key = 1;
inline bool HdsPKdf::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsPKdf::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsPKdf::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsPKdf.key)
  return key_.GetNoArena();
}
inline void HdsPKdf::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsPKdf.key)
}
#if LANG_CXX11
inline void HdsPKdf::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsPKdf.key)
}
#endif
inline void HdsPKdf::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsPKdf.key)
}
inline void HdsPKdf::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsPKdf.key)
}
inline ::std::string* HdsPKdf::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsPKdf.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsPKdf::release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsPKdf.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsPKdf::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsPKdf.key)
}

// optional .hw.trezor.messages.hds.HdsECCPoint cofactor_G = 2;
inline bool HdsPKdf::has_cofactor_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsPKdf::clear_cofactor_g() {
  if (cofactor_g_ != nullptr) cofactor_g_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsPKdf::cofactor_g() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = cofactor_g_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsPKdf.cofactor_G)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsPKdf::release_cofactor_g() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsPKdf.cofactor_G)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = cofactor_g_;
  cofactor_g_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsPKdf::mutable_cofactor_g() {
  _has_bits_[0] |= 0x00000002u;
  if (cofactor_g_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    cofactor_g_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsPKdf.cofactor_G)
  return cofactor_g_;
}
inline void HdsPKdf::set_allocated_cofactor_g(::hw::trezor::messages::hds::HdsECCPoint* cofactor_g) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cofactor_g_;
  }
  if (cofactor_g) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cofactor_g = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cofactor_g, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cofactor_g_ = cofactor_g;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsPKdf.cofactor_G)
}

// optional .hw.trezor.messages.hds.HdsECCPoint cofactor_J = 3;
inline bool HdsPKdf::has_cofactor_j() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsPKdf::clear_cofactor_j() {
  if (cofactor_j_ != nullptr) cofactor_j_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsPKdf::cofactor_j() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = cofactor_j_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsPKdf.cofactor_J)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsPKdf::release_cofactor_j() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsPKdf.cofactor_J)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = cofactor_j_;
  cofactor_j_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsPKdf::mutable_cofactor_j() {
  _has_bits_[0] |= 0x00000004u;
  if (cofactor_j_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    cofactor_j_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsPKdf.cofactor_J)
  return cofactor_j_;
}
inline void HdsPKdf::set_allocated_cofactor_j(::hw::trezor::messages::hds::HdsECCPoint* cofactor_j) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cofactor_j_;
  }
  if (cofactor_j) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cofactor_j = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cofactor_j, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cofactor_j_ = cofactor_j;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsPKdf.cofactor_J)
}

// -------------------------------------------------------------------

// HdsGetNumSlots

// optional bool show_display = 1;
inline bool HdsGetNumSlots::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsGetNumSlots::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool HdsGetNumSlots::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsGetNumSlots.show_display)
  return show_display_;
}
inline void HdsGetNumSlots::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsGetNumSlots.show_display)
}

// -------------------------------------------------------------------

// HdsNumSlots

// optional uint32 num_slots = 1;
inline bool HdsNumSlots::has_num_slots() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsNumSlots::clear_num_slots() {
  num_slots_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 HdsNumSlots::num_slots() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsNumSlots.num_slots)
  return num_slots_;
}
inline void HdsNumSlots::set_num_slots(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_slots_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsNumSlots.num_slots)
}

// -------------------------------------------------------------------

// HdsTxCommon_HdsKernelParameters

// optional uint64 fee = 1;
inline bool HdsTxCommon_HdsKernelParameters::has_fee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsTxCommon_HdsKernelParameters::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 HdsTxCommon_HdsKernelParameters::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.fee)
  return fee_;
}
inline void HdsTxCommon_HdsKernelParameters::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.fee)
}

// optional uint64 min_height = 2;
inline bool HdsTxCommon_HdsKernelParameters::has_min_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsTxCommon_HdsKernelParameters::clear_min_height() {
  min_height_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 HdsTxCommon_HdsKernelParameters::min_height() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.min_height)
  return min_height_;
}
inline void HdsTxCommon_HdsKernelParameters::set_min_height(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  min_height_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.min_height)
}

// optional uint64 max_height = 3;
inline bool HdsTxCommon_HdsKernelParameters::has_max_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HdsTxCommon_HdsKernelParameters::clear_max_height() {
  max_height_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 HdsTxCommon_HdsKernelParameters::max_height() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.max_height)
  return max_height_;
}
inline void HdsTxCommon_HdsKernelParameters::set_max_height(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  max_height_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.max_height)
}

// optional .hw.trezor.messages.hds.HdsECCPoint commitment = 4;
inline bool HdsTxCommon_HdsKernelParameters::has_commitment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsTxCommon_HdsKernelParameters::clear_commitment() {
  if (commitment_ != nullptr) commitment_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsECCPoint& HdsTxCommon_HdsKernelParameters::commitment() const {
  const ::hw::trezor::messages::hds::HdsECCPoint* p = commitment_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.commitment)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsECCPoint*>(
      &::hw::trezor::messages::hds::_HdsECCPoint_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsTxCommon_HdsKernelParameters::release_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.commitment)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsECCPoint* temp = commitment_;
  commitment_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsECCPoint* HdsTxCommon_HdsKernelParameters::mutable_commitment() {
  _has_bits_[0] |= 0x00000001u;
  if (commitment_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsECCPoint>(GetArenaNoVirtual());
    commitment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.commitment)
  return commitment_;
}
inline void HdsTxCommon_HdsKernelParameters::set_allocated_commitment(::hw::trezor::messages::hds::HdsECCPoint* commitment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete commitment_;
  }
  if (commitment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      commitment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commitment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commitment_ = commitment;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.commitment)
}

// optional .hw.trezor.messages.hds.HdsSignature signature = 5;
inline bool HdsTxCommon_HdsKernelParameters::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsTxCommon_HdsKernelParameters::clear_signature() {
  if (signature_ != nullptr) signature_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsSignature& HdsTxCommon_HdsKernelParameters::signature() const {
  const ::hw::trezor::messages::hds::HdsSignature* p = signature_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.signature)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignature*>(
      &::hw::trezor::messages::hds::_HdsSignature_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsTxCommon_HdsKernelParameters::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.signature)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsSignature* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsTxCommon_HdsKernelParameters::mutable_signature() {
  _has_bits_[0] |= 0x00000002u;
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignature>(GetArenaNoVirtual());
    signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.signature)
  return signature_;
}
inline void HdsTxCommon_HdsKernelParameters::set_allocated_signature(::hw::trezor::messages::hds::HdsSignature* signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters.signature)
}

// -------------------------------------------------------------------

// HdsTxCommon

// repeated .hw.trezor.messages.hds.HdsCoinID inputs = 1;
inline int HdsTxCommon::inputs_size() const {
  return inputs_.size();
}
inline void HdsTxCommon::clear_inputs() {
  inputs_.Clear();
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsTxCommon::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >*
HdsTxCommon::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.hds.HdsTxCommon.inputs)
  return &inputs_;
}
inline const ::hw::trezor::messages::hds::HdsCoinID& HdsTxCommon::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.inputs)
  return inputs_.Get(index);
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsTxCommon::add_inputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.hds.HdsTxCommon.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >&
HdsTxCommon::inputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.hds.HdsTxCommon.inputs)
  return inputs_;
}

// optional bytes offset_sk = 2;
inline bool HdsTxCommon::has_offset_sk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsTxCommon::clear_offset_sk() {
  offset_sk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsTxCommon::offset_sk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
  return offset_sk_.GetNoArena();
}
inline void HdsTxCommon::set_offset_sk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
}
#if LANG_CXX11
inline void HdsTxCommon::set_offset_sk(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
}
#endif
inline void HdsTxCommon::set_offset_sk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
}
inline void HdsTxCommon::set_offset_sk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  offset_sk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
}
inline ::std::string* HdsTxCommon::mutable_offset_sk() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
  return offset_sk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsTxCommon::release_offset_sk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
  if (!has_offset_sk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return offset_sk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsTxCommon::set_allocated_offset_sk(::std::string* offset_sk) {
  if (offset_sk != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  offset_sk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), offset_sk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxCommon.offset_sk)
}

// repeated .hw.trezor.messages.hds.HdsCoinID outputs = 3;
inline int HdsTxCommon::outputs_size() const {
  return outputs_.size();
}
inline void HdsTxCommon::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsTxCommon::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >*
HdsTxCommon::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.hds.HdsTxCommon.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::hds::HdsCoinID& HdsTxCommon::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::hds::HdsCoinID* HdsTxCommon::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.hds.HdsTxCommon.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::hds::HdsCoinID >&
HdsTxCommon::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.hds.HdsTxCommon.outputs)
  return outputs_;
}

// optional .hw.trezor.messages.hds.HdsTxCommon.HdsKernelParameters kernel_params = 4;
inline bool HdsTxCommon::has_kernel_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsTxCommon::clear_kernel_params() {
  if (kernel_params_ != nullptr) kernel_params_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters& HdsTxCommon::kernel_params() const {
  const ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* p = kernel_params_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxCommon.kernel_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters*>(
      &::hw::trezor::messages::hds::_HdsTxCommon_HdsKernelParameters_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* HdsTxCommon::release_kernel_params() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxCommon.kernel_params)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* temp = kernel_params_;
  kernel_params_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* HdsTxCommon::mutable_kernel_params() {
  _has_bits_[0] |= 0x00000002u;
  if (kernel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters>(GetArenaNoVirtual());
    kernel_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxCommon.kernel_params)
  return kernel_params_;
}
inline void HdsTxCommon::set_allocated_kernel_params(::hw::trezor::messages::hds::HdsTxCommon_HdsKernelParameters* kernel_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kernel_params_;
  }
  if (kernel_params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kernel_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kernel_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  kernel_params_ = kernel_params;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxCommon.kernel_params)
}

// -------------------------------------------------------------------

// HdsTxMutualInfo

// optional bytes peer = 1;
inline bool HdsTxMutualInfo::has_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsTxMutualInfo::clear_peer() {
  peer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsTxMutualInfo::peer() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
  return peer_.GetNoArena();
}
inline void HdsTxMutualInfo::set_peer(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
}
#if LANG_CXX11
inline void HdsTxMutualInfo::set_peer(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
}
#endif
inline void HdsTxMutualInfo::set_peer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
}
inline void HdsTxMutualInfo::set_peer(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
}
inline ::std::string* HdsTxMutualInfo::mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
  return peer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsTxMutualInfo::release_peer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
  if (!has_peer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return peer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsTxMutualInfo::set_allocated_peer(::std::string* peer) {
  if (peer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxMutualInfo.peer)
}

// optional uint64 wallet_identity_key = 2;
inline bool HdsTxMutualInfo::has_wallet_identity_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsTxMutualInfo::clear_wallet_identity_key() {
  wallet_identity_key_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 HdsTxMutualInfo::wallet_identity_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxMutualInfo.wallet_identity_key)
  return wallet_identity_key_;
}
inline void HdsTxMutualInfo::set_wallet_identity_key(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  wallet_identity_key_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsTxMutualInfo.wallet_identity_key)
}

// optional .hw.trezor.messages.hds.HdsSignature payment_proof_signature = 3;
inline bool HdsTxMutualInfo::has_payment_proof_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsTxMutualInfo::clear_payment_proof_signature() {
  if (payment_proof_signature_ != nullptr) payment_proof_signature_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsSignature& HdsTxMutualInfo::payment_proof_signature() const {
  const ::hw::trezor::messages::hds::HdsSignature* p = payment_proof_signature_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsTxMutualInfo.payment_proof_signature)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignature*>(
      &::hw::trezor::messages::hds::_HdsSignature_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsTxMutualInfo::release_payment_proof_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsTxMutualInfo.payment_proof_signature)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsSignature* temp = payment_proof_signature_;
  payment_proof_signature_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignature* HdsTxMutualInfo::mutable_payment_proof_signature() {
  _has_bits_[0] |= 0x00000002u;
  if (payment_proof_signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignature>(GetArenaNoVirtual());
    payment_proof_signature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsTxMutualInfo.payment_proof_signature)
  return payment_proof_signature_;
}
inline void HdsTxMutualInfo::set_allocated_payment_proof_signature(::hw::trezor::messages::hds::HdsSignature* payment_proof_signature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete payment_proof_signature_;
  }
  if (payment_proof_signature) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      payment_proof_signature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payment_proof_signature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payment_proof_signature_ = payment_proof_signature;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsTxMutualInfo.payment_proof_signature)
}

// -------------------------------------------------------------------

// HdsSignTransactionSend

// optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
inline bool HdsSignTransactionSend::has_tx_common() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignTransactionSend::clear_tx_common() {
  if (tx_common_ != nullptr) tx_common_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsTxCommon& HdsSignTransactionSend::tx_common() const {
  const ::hw::trezor::messages::hds::HdsTxCommon* p = tx_common_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSend.tx_common)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxCommon*>(
      &::hw::trezor::messages::hds::_HdsTxCommon_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionSend::release_tx_common() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSend.tx_common)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsTxCommon* temp = tx_common_;
  tx_common_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionSend::mutable_tx_common() {
  _has_bits_[0] |= 0x00000002u;
  if (tx_common_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon>(GetArenaNoVirtual());
    tx_common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSend.tx_common)
  return tx_common_;
}
inline void HdsSignTransactionSend::set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_common_;
  }
  if (tx_common) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx_common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_common, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_common_ = tx_common;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSend.tx_common)
}

// optional .hw.trezor.messages.hds.HdsTxMutualInfo tx_mutual_info = 2;
inline bool HdsSignTransactionSend::has_tx_mutual_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HdsSignTransactionSend::clear_tx_mutual_info() {
  if (tx_mutual_info_ != nullptr) tx_mutual_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::hds::HdsTxMutualInfo& HdsSignTransactionSend::tx_mutual_info() const {
  const ::hw::trezor::messages::hds::HdsTxMutualInfo* p = tx_mutual_info_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSend.tx_mutual_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxMutualInfo*>(
      &::hw::trezor::messages::hds::_HdsTxMutualInfo_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxMutualInfo* HdsSignTransactionSend::release_tx_mutual_info() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSend.tx_mutual_info)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* temp = tx_mutual_info_;
  tx_mutual_info_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxMutualInfo* HdsSignTransactionSend::mutable_tx_mutual_info() {
  _has_bits_[0] |= 0x00000004u;
  if (tx_mutual_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxMutualInfo>(GetArenaNoVirtual());
    tx_mutual_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSend.tx_mutual_info)
  return tx_mutual_info_;
}
inline void HdsSignTransactionSend::set_allocated_tx_mutual_info(::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_mutual_info_;
  }
  if (tx_mutual_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx_mutual_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_mutual_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tx_mutual_info_ = tx_mutual_info;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSend.tx_mutual_info)
}

// optional uint32 nonce_slot = 3;
inline bool HdsSignTransactionSend::has_nonce_slot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HdsSignTransactionSend::clear_nonce_slot() {
  nonce_slot_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 HdsSignTransactionSend::nonce_slot() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSend.nonce_slot)
  return nonce_slot_;
}
inline void HdsSignTransactionSend::set_nonce_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  nonce_slot_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransactionSend.nonce_slot)
}

// optional bytes user_agreement = 4;
inline bool HdsSignTransactionSend::has_user_agreement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionSend::clear_user_agreement() {
  user_agreement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HdsSignTransactionSend::user_agreement() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
  return user_agreement_.GetNoArena();
}
inline void HdsSignTransactionSend::set_user_agreement(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
}
#if LANG_CXX11
inline void HdsSignTransactionSend::set_user_agreement(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  user_agreement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
}
#endif
inline void HdsSignTransactionSend::set_user_agreement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  user_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
}
inline void HdsSignTransactionSend::set_user_agreement(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  user_agreement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
}
inline ::std::string* HdsSignTransactionSend::mutable_user_agreement() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
  return user_agreement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HdsSignTransactionSend::release_user_agreement() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
  if (!has_user_agreement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return user_agreement_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HdsSignTransactionSend::set_allocated_user_agreement(::std::string* user_agreement) {
  if (user_agreement != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_agreement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_agreement);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSend.user_agreement)
}

// -------------------------------------------------------------------

// HdsSignTransactionSendResult

// optional .hw.trezor.messages.hds.HdsSignTransactionSend tx = 1;
inline bool HdsSignTransactionSendResult::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionSendResult::clear_tx() {
  if (tx_ != nullptr) tx_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsSignTransactionSend& HdsSignTransactionSendResult::tx() const {
  const ::hw::trezor::messages::hds::HdsSignTransactionSend* p = tx_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSendResult.tx)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignTransactionSend*>(
      &::hw::trezor::messages::hds::_HdsSignTransactionSend_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignTransactionSend* HdsSignTransactionSendResult::release_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSendResult.tx)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsSignTransactionSend* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignTransactionSend* HdsSignTransactionSendResult::mutable_tx() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSend>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSendResult.tx)
  return tx_;
}
inline void HdsSignTransactionSendResult::set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionSend* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSendResult.tx)
}

// -------------------------------------------------------------------

// HdsSignTransactionReceive

// optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
inline bool HdsSignTransactionReceive::has_tx_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionReceive::clear_tx_common() {
  if (tx_common_ != nullptr) tx_common_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsTxCommon& HdsSignTransactionReceive::tx_common() const {
  const ::hw::trezor::messages::hds::HdsTxCommon* p = tx_common_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_common)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxCommon*>(
      &::hw::trezor::messages::hds::_HdsTxCommon_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionReceive::release_tx_common() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_common)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsTxCommon* temp = tx_common_;
  tx_common_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionReceive::mutable_tx_common() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_common_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon>(GetArenaNoVirtual());
    tx_common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_common)
  return tx_common_;
}
inline void HdsSignTransactionReceive::set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_common_;
  }
  if (tx_common) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx_common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_common, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_common_ = tx_common;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_common)
}

// optional .hw.trezor.messages.hds.HdsTxMutualInfo tx_mutual_info = 2;
inline bool HdsSignTransactionReceive::has_tx_mutual_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HdsSignTransactionReceive::clear_tx_mutual_info() {
  if (tx_mutual_info_ != nullptr) tx_mutual_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::hds::HdsTxMutualInfo& HdsSignTransactionReceive::tx_mutual_info() const {
  const ::hw::trezor::messages::hds::HdsTxMutualInfo* p = tx_mutual_info_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_mutual_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxMutualInfo*>(
      &::hw::trezor::messages::hds::_HdsTxMutualInfo_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxMutualInfo* HdsSignTransactionReceive::release_tx_mutual_info() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_mutual_info)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::hds::HdsTxMutualInfo* temp = tx_mutual_info_;
  tx_mutual_info_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxMutualInfo* HdsSignTransactionReceive::mutable_tx_mutual_info() {
  _has_bits_[0] |= 0x00000002u;
  if (tx_mutual_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxMutualInfo>(GetArenaNoVirtual());
    tx_mutual_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_mutual_info)
  return tx_mutual_info_;
}
inline void HdsSignTransactionReceive::set_allocated_tx_mutual_info(::hw::trezor::messages::hds::HdsTxMutualInfo* tx_mutual_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_mutual_info_;
  }
  if (tx_mutual_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx_mutual_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_mutual_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_mutual_info_ = tx_mutual_info;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionReceive.tx_mutual_info)
}

// -------------------------------------------------------------------

// HdsSignTransactionReceiveResult

// optional .hw.trezor.messages.hds.HdsSignTransactionReceive tx = 1;
inline bool HdsSignTransactionReceiveResult::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionReceiveResult::clear_tx() {
  if (tx_ != nullptr) tx_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsSignTransactionReceive& HdsSignTransactionReceiveResult::tx() const {
  const ::hw::trezor::messages::hds::HdsSignTransactionReceive* p = tx_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionReceiveResult.tx)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignTransactionReceive*>(
      &::hw::trezor::messages::hds::_HdsSignTransactionReceive_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignTransactionReceive* HdsSignTransactionReceiveResult::release_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionReceiveResult.tx)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsSignTransactionReceive* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignTransactionReceive* HdsSignTransactionReceiveResult::mutable_tx() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionReceive>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionReceiveResult.tx)
  return tx_;
}
inline void HdsSignTransactionReceiveResult::set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionReceive* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionReceiveResult.tx)
}

// -------------------------------------------------------------------

// HdsSignTransactionSplit

// optional .hw.trezor.messages.hds.HdsTxCommon tx_common = 1;
inline bool HdsSignTransactionSplit::has_tx_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionSplit::clear_tx_common() {
  if (tx_common_ != nullptr) tx_common_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsTxCommon& HdsSignTransactionSplit::tx_common() const {
  const ::hw::trezor::messages::hds::HdsTxCommon* p = tx_common_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSplit.tx_common)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsTxCommon*>(
      &::hw::trezor::messages::hds::_HdsTxCommon_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionSplit::release_tx_common() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSplit.tx_common)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsTxCommon* temp = tx_common_;
  tx_common_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsTxCommon* HdsSignTransactionSplit::mutable_tx_common() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_common_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsTxCommon>(GetArenaNoVirtual());
    tx_common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSplit.tx_common)
  return tx_common_;
}
inline void HdsSignTransactionSplit::set_allocated_tx_common(::hw::trezor::messages::hds::HdsTxCommon* tx_common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_common_;
  }
  if (tx_common) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx_common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_common, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_common_ = tx_common;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSplit.tx_common)
}

// -------------------------------------------------------------------

// HdsSignTransactionSplitResult

// optional .hw.trezor.messages.hds.HdsSignTransactionSplit tx = 1;
inline bool HdsSignTransactionSplitResult::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdsSignTransactionSplitResult::clear_tx() {
  if (tx_ != nullptr) tx_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::hds::HdsSignTransactionSplit& HdsSignTransactionSplitResult::tx() const {
  const ::hw::trezor::messages::hds::HdsSignTransactionSplit* p = tx_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.hds.HdsSignTransactionSplitResult.tx)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::hds::HdsSignTransactionSplit*>(
      &::hw::trezor::messages::hds::_HdsSignTransactionSplit_default_instance_);
}
inline ::hw::trezor::messages::hds::HdsSignTransactionSplit* HdsSignTransactionSplitResult::release_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.hds.HdsSignTransactionSplitResult.tx)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::hds::HdsSignTransactionSplit* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::hds::HdsSignTransactionSplit* HdsSignTransactionSplitResult::mutable_tx() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::hds::HdsSignTransactionSplit>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.hds.HdsSignTransactionSplitResult.tx)
  return tx_;
}
inline void HdsSignTransactionSplitResult::set_allocated_tx(::hw::trezor::messages::hds::HdsSignTransactionSplit* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.hds.HdsSignTransactionSplitResult.tx)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hds
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dhds_2eproto
